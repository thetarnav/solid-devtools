diff --git a/dist/dev.cjs b/dist/dev.cjs
index 167f46db6c602046179dac32a285a63081c9962b..56378faedce8e046950405965663d4f7130deb15 100644
--- a/dist/dev.cjs
+++ b/dist/dev.cjs
@@ -275,14 +275,14 @@ function createResource(pSource, pFetcher, pOptions) {
   let source;
   let fetcher;
   let options;
-  if (arguments.length === 2 && typeof pFetcher === "object" || arguments.length === 1) {
-    source = true;
-    fetcher = pSource;
-    options = pFetcher || {};
-  } else {
+  if (typeof pFetcher === "function") {
     source = pSource;
     fetcher = pFetcher;
     options = pOptions || {};
+  } else {
+    source = true;
+    fetcher = pSource;
+    options = pFetcher || {};
   }
   let pr = null,
     initP = NO_INIT,
@@ -1750,12 +1750,20 @@ function Suspense(props) {
 }
 
 const DEV = {
+  version: "1.9.3",
+  getOwner: getOwner,
+  getListener: getListener,
+  $PROXY: $PROXY,
+  $DEVCOMP: $DEVCOMP,
+  $TRACK: $TRACK,
   hooks: DevHooks,
-  writeSignal,
-  registerGraph
+  readSignal: readSignal,
+  writeSignal: writeSignal,
+  registerGraph: registerGraph,
+  sharedConfig: sharedConfig
 } ;
 if (globalThis) {
-  if (!globalThis.Solid$$) globalThis.Solid$$ = true;else console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior.");
+  if (!globalThis.Solid$$) globalThis.Solid$$ = DEV;else console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior.");
 }
 
 exports.$DEVCOMP = $DEVCOMP;
diff --git a/dist/dev.js b/dist/dev.js
index 1aa04011e0aa28d0ef33f21a2f94d11533acdaea..09b3748094d8a2f9d3d1013a3c014f04e12e0b28 100644
--- a/dist/dev.js
+++ b/dist/dev.js
@@ -52,11 +52,9 @@ function enqueue(taskQueue, task) {
     let m = 0;
     let n = taskQueue.length - 1;
     while (m <= n) {
-      const k = (n + m) >> 1;
+      const k = n + m >> 1;
       const cmp = task.expirationTime - taskQueue[k].expirationTime;
-      if (cmp > 0) m = k + 1;
-      else if (cmp < 0) n = k - 1;
-      else return k;
+      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;
     }
     return m;
   }
@@ -181,25 +179,20 @@ function createRoot(fn, detachedOwner) {
     owner = Owner,
     unowned = fn.length === 0,
     current = detachedOwner === undefined ? owner : detachedOwner,
-    root = unowned
-      ? {
-          owned: null,
-          cleanups: null,
-          context: null,
-          owner: null
-        }
-      : {
-          owned: null,
-          cleanups: null,
-          context: current ? current.context : null,
-          owner: current
-        },
-    updateFn = unowned
-      ? () =>
-          fn(() => {
-            throw new Error("Dispose method must be an explicit argument to createRoot function");
-          })
-      : () => fn(() => untrack(() => cleanNode(root)));
+    root = unowned ? {
+      owned: null,
+      cleanups: null,
+      context: null,
+      owner: null
+    }  : {
+      owned: null,
+      cleanups: null,
+      context: current ? current.context : null,
+      owner: current
+    },
+    updateFn = unowned ? () => fn(() => {
+      throw new Error("Dispose method must be an explicit argument to createRoot function");
+    })  : () => fn(() => untrack(() => cleanNode(root)));
   DevHooks.afterCreateOwner && DevHooks.afterCreateOwner(root);
   Owner = root;
   Listener = null;
@@ -225,26 +218,23 @@ function createSignal(value, options) {
   }
   const setter = value => {
     if (typeof value === "function") {
-      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);
-      else value = value(s.value);
+      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);else value = value(s.value);
     }
     return writeSignal(s, value);
   };
   return [readSignal.bind(s), setter];
 }
 function createComputed(fn, value, options) {
-  const c = createComputation(fn, value, true, STALE, options);
-  if (Scheduler && Transition && Transition.running) Updates.push(c);
-  else updateComputation(c);
+  const c = createComputation(fn, value, true, STALE, options );
+  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);
 }
 function createRenderEffect(fn, value, options) {
-  const c = createComputation(fn, value, false, STALE, options);
-  if (Scheduler && Transition && Transition.running) Updates.push(c);
-  else updateComputation(c);
+  const c = createComputation(fn, value, false, STALE, options );
+  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);
 }
 function createEffect(fn, value, options) {
   runEffects = runUserEffects;
-  const c = createComputation(fn, value, false, STALE, options),
+  const c = createComputation(fn, value, false, STALE, options ),
     s = SuspenseContext && useContext(SuspenseContext);
   if (s) c.suspense = s;
   if (!options || !options.render) c.user = true;
@@ -252,16 +242,10 @@ function createEffect(fn, value, options) {
 }
 function createReaction(onInvalidate, options) {
   let fn;
-  const c = createComputation(
-      () => {
-        fn ? fn() : untrack(onInvalidate);
-        fn = undefined;
-      },
-      undefined,
-      false,
-      0,
-      options
-    ),
+  const c = createComputation(() => {
+      fn ? fn() : untrack(onInvalidate);
+      fn = undefined;
+    }, undefined, false, 0, options ),
     s = SuspenseContext && useContext(SuspenseContext);
   if (s) c.suspense = s;
   c.user = true;
@@ -272,7 +256,7 @@ function createReaction(onInvalidate, options) {
 }
 function createMemo(fn, value, options) {
   options = options ? Object.assign({}, signalOptions, options) : signalOptions;
-  const c = createComputation(fn, value, true, 0, options);
+  const c = createComputation(fn, value, true, 0, options );
   c.observers = null;
   c.observerSlots = null;
   c.comparator = options.equals || undefined;
@@ -289,14 +273,14 @@ function createResource(pSource, pFetcher, pOptions) {
   let source;
   let fetcher;
   let options;
-  if ((arguments.length === 2 && typeof pFetcher === "object") || arguments.length === 1) {
-    source = true;
-    fetcher = pSource;
-    options = pFetcher || {};
-  } else {
+  if (typeof pFetcher === "function") {
     source = pSource;
     fetcher = pFetcher;
     options = pOptions || {};
+  } else {
+    source = true;
+    fetcher = pSource;
+    options = pFetcher || {};
   }
   let pr = null,
     initP = NO_INIT,
@@ -314,19 +298,15 @@ function createResource(pSource, pFetcher, pOptions) {
     [state, setState] = createSignal(resolved ? "ready" : "unresolved");
   if (sharedConfig.context) {
     id = sharedConfig.getNextContextId();
-    if (options.ssrLoadFrom === "initial") initP = options.initialValue;
-    else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
+    if (options.ssrLoadFrom === "initial") initP = options.initialValue;else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
   }
   function loadEnd(p, v, error, key) {
     if (pr === p) {
       pr = null;
       key !== undefined && (resolved = true);
-      if ((p === initP || v === initP) && options.onHydrated)
-        queueMicrotask(() =>
-          options.onHydrated(key, {
-            value: v
-          })
-        );
+      if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {
+        value: v
+      }));
       initP = NO_INIT;
       if (Transition && p && loadedUnderTransition) {
         Transition.promises.delete(p);
@@ -357,8 +337,7 @@ function createResource(pSource, pFetcher, pOptions) {
       createComputed(() => {
         track();
         if (pr) {
-          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);
-          else if (!contexts.has(c)) {
+          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);else if (!contexts.has(c)) {
             c.increment();
             contexts.add(c);
           }
@@ -377,35 +356,26 @@ function createResource(pSource, pFetcher, pOptions) {
       return;
     }
     if (Transition && pr) Transition.promises.delete(pr);
-    const p =
-      initP !== NO_INIT
-        ? initP
-        : untrack(() =>
-            fetcher(lookup, {
-              value: value(),
-              refetching
-            })
-          );
+    const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup, {
+      value: value(),
+      refetching
+    }));
     if (!isPromise(p)) {
       loadEnd(pr, p, undefined, lookup);
       return p;
     }
     pr = p;
     if ("value" in p) {
-      if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);
-      else loadEnd(pr, undefined, castError(p.value), lookup);
+      if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);else loadEnd(pr, undefined, castError(p.value), lookup);
       return p;
     }
     scheduled = true;
-    queueMicrotask(() => (scheduled = false));
+    queueMicrotask(() => scheduled = false);
     runUpdates(() => {
       setState(resolved ? "refreshing" : "pending");
       trigger();
     }, false);
-    return p.then(
-      v => loadEnd(p, v, undefined, lookup),
-      e => loadEnd(p, undefined, castError(e), lookup)
-    );
+    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, undefined, castError(e), lookup));
   }
   Object.defineProperties(read, {
     state: {
@@ -429,81 +399,50 @@ function createResource(pSource, pFetcher, pOptions) {
       }
     }
   });
-  if (dynamic) createComputed(() => load(false));
-  else load(false);
-  return [
-    read,
-    {
-      refetch: load,
-      mutate: setValue
-    }
-  ];
+  if (dynamic) createComputed(() => load(false));else load(false);
+  return [read, {
+    refetch: load,
+    mutate: setValue
+  }];
 }
 function createDeferred(source, options) {
   let t,
     timeout = options ? options.timeoutMs : undefined;
-  const node = createComputation(
-    () => {
-      if (!t || !t.fn)
-        t = requestCallback(
-          () => setDeferred(() => node.value),
-          timeout !== undefined
-            ? {
-                timeout
-              }
-            : undefined
-        );
-      return source();
-    },
-    undefined,
-    true
-  );
-  const [deferred, setDeferred] = createSignal(
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
-    options
-  );
+  const node = createComputation(() => {
+    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {
+      timeout
+    } : undefined);
+    return source();
+  }, undefined, true);
+  const [deferred, setDeferred] = createSignal(Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, options);
   updateComputation(node);
-  setDeferred(() =>
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value
-  );
+  setDeferred(() => Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
   return deferred;
 }
 function createSelector(source, fn = equalFn, options) {
   const subs = new Map();
-  const node = createComputation(
-    p => {
-      const v = source();
-      for (const [key, val] of subs.entries())
-        if (fn(key, v) !== fn(key, p)) {
-          for (const c of val.values()) {
-            c.state = STALE;
-            if (c.pure) Updates.push(c);
-            else Effects.push(c);
-          }
-        }
-      return v;
-    },
-    undefined,
-    true,
-    STALE,
-    options
-  );
+  const node = createComputation(p => {
+    const v = source();
+    for (const [key, val] of subs.entries()) if (fn(key, v) !== fn(key, p)) {
+      for (const c of val.values()) {
+        c.state = STALE;
+        if (c.pure) Updates.push(c);else Effects.push(c);
+      }
+    }
+    return v;
+  }, undefined, true, STALE, options );
   updateComputation(node);
   return key => {
     const listener = Listener;
     if (listener) {
       let l;
-      if ((l = subs.get(key))) l.add(listener);
-      else subs.set(key, (l = new Set([listener])));
+      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));
       onCleanup(() => {
         l.delete(listener);
         !l.size && subs.delete(key);
       });
     }
-    return fn(
-      key,
-      Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value
-    );
+    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
   };
 }
 function batch(fn) {
@@ -543,10 +482,7 @@ function onMount(fn) {
   createEffect(() => untrack(fn));
 }
 function onCleanup(fn) {
-  if (Owner === null)
-    console.warn("cleanups created outside a `createRoot` or `render` will never be run");
-  else if (Owner.cleanups === null) Owner.cleanups = [fn];
-  else Owner.cleanups.push(fn);
+  if (Owner === null) console.warn("cleanups created outside a `createRoot` or `render` will never be run");else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);
   return fn;
 }
 function catchError(fn, handler) {
@@ -600,17 +536,15 @@ function startTransition(fn) {
     Owner = o;
     let t;
     if (Scheduler || SuspenseContext) {
-      t =
-        Transition ||
-        (Transition = {
-          sources: new Set(),
-          effects: [],
-          promises: new Set(),
-          disposed: new Set(),
-          queue: new Set(),
-          running: true
-        });
-      t.done || (t.done = new Promise(res => (t.resolve = res)));
+      t = Transition || (Transition = {
+        sources: new Set(),
+        effects: [],
+        promises: new Set(),
+        disposed: new Set(),
+        queue: new Set(),
+        running: true
+      });
+      t.done || (t.done = new Promise(res => t.resolve = res));
       t.running = true;
     }
     runUpdates(fn, false);
@@ -618,7 +552,7 @@ function startTransition(fn) {
     return t ? t.done : undefined;
   });
 }
-const [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);
+const [transPending, setTransPending] = /*@__PURE__*/createSignal(false);
 function useTransition() {
   return [transPending, startTransition];
 }
@@ -627,18 +561,12 @@ function resumeEffects(e) {
   e.length = 0;
 }
 function devComponent(Comp, props) {
-  const c = createComputation(
-    () =>
-      untrack(() => {
-        Object.assign(Comp, {
-          [$DEVCOMP]: true
-        });
-        return Comp(props);
-      }),
-    undefined,
-    true,
-    0
-  );
+  const c = createComputation(() => untrack(() => {
+    Object.assign(Comp, {
+      [$DEVCOMP]: true
+    });
+    return Comp(props);
+  }), undefined, true, 0);
   c.props = props;
   c.observers = null;
   c.observerSlots = null;
@@ -649,8 +577,7 @@ function devComponent(Comp, props) {
 }
 function registerGraph(value) {
   if (!Owner) return;
-  if (Owner.sourceMap) Owner.sourceMap.push(value);
-  else Owner.sourceMap = [value];
+  if (Owner.sourceMap) Owner.sourceMap.push(value);else Owner.sourceMap = [value];
   value.graph = Owner;
 }
 function createContext(defaultValue, options) {
@@ -663,15 +590,13 @@ function createContext(defaultValue, options) {
 }
 function useContext(context) {
   let value;
-  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined
-    ? value
-    : context.defaultValue;
+  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined ? value : context.defaultValue;
 }
 function children(fn) {
   const children = createMemo(fn);
   const memo = createMemo(() => resolveChildren(children()), undefined, {
     name: "children"
-  });
+  }) ;
   memo.toArray = () => {
     const c = memo();
     return Array.isArray(c) ? c : c != null ? [c] : [];
@@ -684,7 +609,10 @@ function getSuspenseContext() {
 }
 function enableExternalSource(factory, untrack = fn => fn()) {
   if (ExternalSourceConfig) {
-    const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;
+    const {
+      factory: oldFactory,
+      untrack: oldUntrack
+    } = ExternalSourceConfig;
     ExternalSourceConfig = {
       factory: (fn, trigger) => {
         const oldSource = oldFactory(fn, trigger);
@@ -709,8 +637,7 @@ function enableExternalSource(factory, untrack = fn => fn()) {
 function readSignal() {
   const runningTransition = Transition && Transition.running;
   if (this.sources && (runningTransition ? this.tState : this.state)) {
-    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
-    else {
+    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);else {
       const updates = Updates;
       Updates = null;
       runUpdates(() => lookUpstream(this), false);
@@ -738,12 +665,11 @@ function readSignal() {
   return this.value;
 }
 function writeSignal(node, value, isComp) {
-  let current =
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
+  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
   if (!node.comparator || !node.comparator(current, value)) {
     if (Transition) {
       const TransitionRunning = Transition.running;
-      if (TransitionRunning || (!isComp && Transition.sources.has(node))) {
+      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
         Transition.sources.add(node);
         node.tValue = value;
       }
@@ -756,12 +682,10 @@ function writeSignal(node, value, isComp) {
           const TransitionRunning = Transition && Transition.running;
           if (TransitionRunning && Transition.disposed.has(o)) continue;
           if (TransitionRunning ? !o.tState : !o.state) {
-            if (o.pure) Updates.push(o);
-            else Effects.push(o);
+            if (o.pure) Updates.push(o);else Effects.push(o);
             if (o.observers) markDownstream(o);
           }
-          if (!TransitionRunning) o.state = STALE;
-          else o.tState = STALE;
+          if (!TransitionRunning) o.state = STALE;else o.tState = STALE;
         }
         if (Updates.length > 10e5) {
           Updates = [];
@@ -777,11 +701,7 @@ function updateComputation(node) {
   if (!node.fn) return;
   cleanNode(node);
   const time = ExecCount;
-  runComputation(
-    node,
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
-    time
-  );
+  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
   if (Transition && !Transition.running && Transition.sources.has(node)) {
     queueMicrotask(() => {
       runUpdates(() => {
@@ -846,15 +766,11 @@ function createComputation(fn, init, pure, state = STALE, options) {
     c.state = 0;
     c.tState = state;
   }
-  if (Owner === null)
-    console.warn("computations created outside a `createRoot` or `render` will never be disposed");
-  else if (Owner !== UNOWNED) {
+  if (Owner === null) console.warn("computations created outside a `createRoot` or `render` will never be disposed");else if (Owner !== UNOWNED) {
     if (Transition && Transition.running && Owner.pure) {
-      if (!Owner.tOwned) Owner.tOwned = [c];
-      else Owner.tOwned.push(c);
+      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);
     } else {
-      if (!Owner.owned) Owner.owned = [c];
-      else Owner.owned.push(c);
+      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);
     }
   }
   if (options && options.name) c.name = options.name;
@@ -907,8 +823,7 @@ function runUpdates(fn, init) {
   if (Updates) return fn();
   let wait = false;
   if (!init) Updates = [];
-  if (Effects) wait = true;
-  else Effects = [];
+  if (Effects) wait = true;else Effects = [];
   ExecCount++;
   try {
     const res = fn();
@@ -922,8 +837,7 @@ function runUpdates(fn, init) {
 }
 function completeUpdates(wait) {
   if (Updates) {
-    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
-    else runQueue(Updates);
+    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);
     Updates = null;
   }
   if (wait) return;
@@ -963,8 +877,7 @@ function completeUpdates(wait) {
   }
   const e = Effects;
   Effects = null;
-  if (e.length) runUpdates(() => runEffects(e), false);
-  else DevHooks.afterUpdate && DevHooks.afterUpdate();
+  if (e.length) runUpdates(() => runEffects(e), false);else DevHooks.afterUpdate && DevHooks.afterUpdate();
   if (res) res();
 }
 function runQueue(queue) {
@@ -992,8 +905,7 @@ function runUserEffects(queue) {
     userLength = 0;
   for (i = 0; i < queue.length; i++) {
     const e = queue[i];
-    if (!e.user) runTop(e);
-    else queue[userLength++] = e;
+    if (!e.user) runTop(e);else queue[userLength++] = e;
   }
   if (sharedConfig.context) {
     if (sharedConfig.count) {
@@ -1012,15 +924,13 @@ function runUserEffects(queue) {
 }
 function lookUpstream(node, ignore) {
   const runningTransition = Transition && Transition.running;
-  if (runningTransition) node.tState = 0;
-  else node.state = 0;
+  if (runningTransition) node.tState = 0;else node.state = 0;
   for (let i = 0; i < node.sources.length; i += 1) {
     const source = node.sources[i];
     if (source.sources) {
       const state = runningTransition ? source.tState : source.state;
       if (state === STALE) {
-        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
-          runTop(source);
+        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
       } else if (state === PENDING) lookUpstream(source, ignore);
     }
   }
@@ -1030,10 +940,8 @@ function markDownstream(node) {
   for (let i = 0; i < node.observers.length; i += 1) {
     const o = node.observers[i];
     if (runningTransition ? !o.tState : !o.state) {
-      if (runningTransition) o.tState = PENDING;
-      else o.state = PENDING;
-      if (o.pure) Updates.push(o);
-      else Effects.push(o);
+      if (runningTransition) o.tState = PENDING;else o.state = PENDING;
+      if (o.pure) Updates.push(o);else Effects.push(o);
       o.observers && markDownstream(o);
     }
   }
@@ -1070,8 +978,7 @@ function cleanNode(node) {
     for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
     node.cleanups = null;
   }
-  if (Transition && Transition.running) node.tState = 0;
-  else node.state = 0;
+  if (Transition && Transition.running) node.tState = 0;else node.state = 0;
   delete node.sourceMap;
 }
 function reset(node, top) {
@@ -1093,21 +1000,19 @@ function runErrors(err, fns, owner) {
   try {
     for (const f of fns) f(err);
   } catch (e) {
-    handleError(e, (owner && owner.owner) || null);
+    handleError(e, owner && owner.owner || null);
   }
 }
 function handleError(err, owner = Owner) {
   const fns = ERROR && owner && owner.context && owner.context[ERROR];
   const error = castError(err);
   if (!fns) throw error;
-  if (Effects)
-    Effects.push({
-      fn() {
-        runErrors(error, fns, owner);
-      },
-      state: STALE
-    });
-  else runErrors(error, fns, owner);
+  if (Effects) Effects.push({
+    fn() {
+      runErrors(error, fns, owner);
+    },
+    state: STALE
+  });else runErrors(error, fns, owner);
 }
 function resolveChildren(children) {
   if (typeof children === "function" && !children.length) return resolveChildren(children());
@@ -1124,26 +1029,19 @@ function resolveChildren(children) {
 function createProvider(id, options) {
   return function provider(props) {
     let res;
-    createRenderEffect(
-      () =>
-        (res = untrack(() => {
-          Owner.context = {
-            ...Owner.context,
-            [id]: props.value
-          };
-          return children(() => props.children);
-        })),
-      undefined,
-      options
-    );
+    createRenderEffect(() => res = untrack(() => {
+      Owner.context = {
+        ...Owner.context,
+        [id]: props.value
+      };
+      return children(() => props.children);
+    }), undefined, options);
     return res;
   };
 }
 function onError(fn) {
   ERROR || (ERROR = Symbol("error"));
-  if (Owner === null)
-    console.warn("error handlers created outside a `createRoot` or `render` will never be run");
-  else if (Owner.context === null || !Owner.context[ERROR]) {
+  if (Owner === null) console.warn("error handlers created outside a `createRoot` or `render` will never be run");else if (Owner.context === null || !Owner.context[ERROR]) {
     Owner.context = {
       ...Owner.context,
       [ERROR]: [fn]
@@ -1172,8 +1070,7 @@ function observable(input) {
       if (!(observer instanceof Object) || observer == null) {
         throw new TypeError("Expected the observer to be an object.");
       }
-      const handler =
-        typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
+      const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
       if (!handler) {
         return {
           unsubscribe() {}
@@ -1204,7 +1101,7 @@ function from(producer) {
   });
   if ("subscribe" in producer) {
     const unsub = producer.subscribe(v => set(() => v));
-    onCleanup(() => ("unsubscribe" in unsub ? unsub.unsubscribe() : unsub()));
+    onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
   } else {
     const clean = producer(set);
     onCleanup(clean);
@@ -1248,7 +1145,8 @@ function mapArray(list, mapFn, options = {}) {
           });
           len = 1;
         }
-      } else if (len === 0) {
+      }
+      else if (len === 0) {
         mapped = new Array(newLen);
         for (j = 0; j < newLen; j++) {
           items[j] = newItems[j];
@@ -1259,16 +1157,8 @@ function mapArray(list, mapFn, options = {}) {
         temp = new Array(newLen);
         tempdisposers = new Array(newLen);
         indexes && (tempIndexes = new Array(newLen));
-        for (
-          start = 0, end = Math.min(len, newLen);
-          start < end && items[start] === newItems[start];
-          start++
-        );
-        for (
-          end = len - 1, newEnd = newLen - 1;
-          end >= start && newEnd >= start && items[end] === newItems[newEnd];
-          end--, newEnd--
-        ) {
+        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);
+        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
           temp[newEnd] = mapped[end];
           tempdisposers[newEnd] = disposers[end];
           indexes && (tempIndexes[newEnd] = indexes[end]);
@@ -1302,7 +1192,7 @@ function mapArray(list, mapFn, options = {}) {
             }
           } else mapped[j] = createRoot(mapper);
         }
-        mapped = mapped.slice(0, (len = newLen));
+        mapped = mapped.slice(0, len = newLen);
         items = newItems.slice(0);
       }
       return mapped;
@@ -1312,7 +1202,7 @@ function mapArray(list, mapFn, options = {}) {
       if (indexes) {
         const [s, set] = createSignal(j, {
           name: "index"
-        });
+        }) ;
         indexes[j] = set;
         return mapFn(newItems[j], s);
       }
@@ -1371,13 +1261,13 @@ function indexArray(list, mapFn, options = {}) {
       }
       len = signals.length = disposers.length = newLen;
       items = newItems.slice(0);
-      return (mapped = mapped.slice(0, len));
+      return mapped = mapped.slice(0, len);
     });
     function mapper(disposer) {
       disposers[i] = disposer;
       const [s, set] = createSignal(newItems[i], {
         name: "value"
-      });
+      }) ;
       signals[i] = set;
       return mapFn(s, i);
     }
@@ -1393,7 +1283,7 @@ function createComponent(Comp, props) {
     if (sharedConfig.context) {
       const c = sharedConfig.context;
       setHydrateContext(nextHydrateContext());
-      const r = devComponent(Comp, props || {});
+      const r = devComponent(Comp, props || {}) ;
       setHydrateContext(c);
       return r;
     }
@@ -1442,33 +1332,29 @@ function mergeProps(...sources) {
   let proxy = false;
   for (let i = 0; i < sources.length; i++) {
     const s = sources[i];
-    proxy = proxy || (!!s && $PROXY in s);
-    sources[i] = typeof s === "function" ? ((proxy = true), createMemo(s)) : s;
+    proxy = proxy || !!s && $PROXY in s;
+    sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
   }
   if (SUPPORTS_PROXY && proxy) {
-    return new Proxy(
-      {
-        get(property) {
-          for (let i = sources.length - 1; i >= 0; i--) {
-            const v = resolveSource(sources[i])[property];
-            if (v !== undefined) return v;
-          }
-        },
-        has(property) {
-          for (let i = sources.length - 1; i >= 0; i--) {
-            if (property in resolveSource(sources[i])) return true;
-          }
-          return false;
-        },
-        keys() {
-          const keys = [];
-          for (let i = 0; i < sources.length; i++)
-            keys.push(...Object.keys(resolveSource(sources[i])));
-          return [...new Set(keys)];
+    return new Proxy({
+      get(property) {
+        for (let i = sources.length - 1; i >= 0; i--) {
+          const v = resolveSource(sources[i])[property];
+          if (v !== undefined) return v;
         }
       },
-      propTraps
-    );
+      has(property) {
+        for (let i = sources.length - 1; i >= 0; i--) {
+          if (property in resolveSource(sources[i])) return true;
+        }
+        return false;
+      },
+      keys() {
+        const keys = [];
+        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
+        return [...new Set(keys)];
+      }
+    }, propTraps);
   }
   const sourcesMap = {};
   const defined = Object.create(null);
@@ -1481,20 +1367,15 @@ function mergeProps(...sources) {
       if (key === "__proto__" || key === "constructor") continue;
       const desc = Object.getOwnPropertyDescriptor(source, key);
       if (!defined[key]) {
-        defined[key] = desc.get
-          ? {
-              enumerable: true,
-              configurable: true,
-              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))
-            }
-          : desc.value !== undefined
-          ? desc
-          : undefined;
+        defined[key] = desc.get ? {
+          enumerable: true,
+          configurable: true,
+          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
+        } : desc.value !== undefined ? desc : undefined;
       } else {
         const sources = sourcesMap[key];
         if (sources) {
-          if (desc.get) sources.push(desc.get.bind(source));
-          else if (desc.value !== undefined) sources.push(() => desc.value);
+          if (desc.get) sources.push(desc.get.bind(source));else if (desc.value !== undefined) sources.push(() => desc.value);
         }
       }
     }
@@ -1504,8 +1385,7 @@ function mergeProps(...sources) {
   for (let i = definedKeys.length - 1; i >= 0; i--) {
     const key = definedKeys[i],
       desc = defined[key];
-    if (desc && desc.get) Object.defineProperty(target, key, desc);
-    else target[key] = desc ? desc.value : undefined;
+    if (desc && desc.get) Object.defineProperty(target, key, desc);else target[key] = desc ? desc.value : undefined;
   }
   return target;
 }
@@ -1513,60 +1393,47 @@ function splitProps(props, ...keys) {
   if (SUPPORTS_PROXY && $PROXY in props) {
     const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
     const res = keys.map(k => {
-      return new Proxy(
-        {
-          get(property) {
-            return k.includes(property) ? props[property] : undefined;
-          },
-          has(property) {
-            return k.includes(property) && property in props;
-          },
-          keys() {
-            return k.filter(property => property in props);
-          }
+      return new Proxy({
+        get(property) {
+          return k.includes(property) ? props[property] : undefined;
         },
-        propTraps
-      );
-    });
-    res.push(
-      new Proxy(
-        {
-          get(property) {
-            return blocked.has(property) ? undefined : props[property];
-          },
-          has(property) {
-            return blocked.has(property) ? false : property in props;
-          },
-          keys() {
-            return Object.keys(props).filter(k => !blocked.has(k));
-          }
+        has(property) {
+          return k.includes(property) && property in props;
         },
-        propTraps
-      )
-    );
+        keys() {
+          return k.filter(property => property in props);
+        }
+      }, propTraps);
+    });
+    res.push(new Proxy({
+      get(property) {
+        return blocked.has(property) ? undefined : props[property];
+      },
+      has(property) {
+        return blocked.has(property) ? false : property in props;
+      },
+      keys() {
+        return Object.keys(props).filter(k => !blocked.has(k));
+      }
+    }, propTraps));
     return res;
   }
   const otherObject = {};
   const objects = keys.map(() => ({}));
   for (const propName of Object.getOwnPropertyNames(props)) {
     const desc = Object.getOwnPropertyDescriptor(props, propName);
-    const isDefaultDesc =
-      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
+    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
     let blocked = false;
     let objectIndex = 0;
     for (const k of keys) {
       if (k.includes(propName)) {
         blocked = true;
-        isDefaultDesc
-          ? (objects[objectIndex][propName] = desc.value)
-          : Object.defineProperty(objects[objectIndex], propName, desc);
+        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
       }
       ++objectIndex;
     }
     if (!blocked) {
-      isDefaultDesc
-        ? (otherObject[propName] = desc.value)
-        : Object.defineProperty(otherObject, propName, desc);
+      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
     }
   }
   return [...objects, otherObject];
@@ -1592,24 +1459,19 @@ function lazy(fn) {
       comp = s;
     }
     let Comp;
-    return createMemo(() =>
-      (Comp = comp())
-        ? untrack(() => {
-            if (true)
-              Object.assign(Comp, {
-                [$DEVCOMP]: true
-              });
-            if (!ctx || sharedConfig.done) return Comp(props);
-            const c = sharedConfig.context;
-            setHydrateContext(ctx);
-            const r = Comp(props);
-            setHydrateContext(c);
-            return r;
-          })
-        : ""
-    );
+    return createMemo(() => (Comp = comp()) ? untrack(() => {
+      if (true) Object.assign(Comp, {
+        [$DEVCOMP]: true
+      });
+      if (!ctx || sharedConfig.done) return Comp(props);
+      const c = sharedConfig.context;
+      setHydrateContext(ctx);
+      const r = Comp(props);
+      setHydrateContext(c);
+      return r;
+    }) : "");
   };
-  wrap.preload = () => p || ((p = fn()).then(mod => (comp = () => mod.default)), p);
+  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);
   return wrap;
 }
 let counter = 0;
@@ -1618,112 +1480,75 @@ function createUniqueId() {
   return ctx ? sharedConfig.getNextContextId() : `cl-${counter++}`;
 }
 
-const narrowedError = name =>
-  `Attempting to access a stale value from <${name}> that could possibly be undefined. This may occur because you are reading the accessor returned from the component at a time where it has already been unmounted. We recommend cleaning up any stale timers or async, or reading from the initial condition.`;
+const narrowedError = name => `Attempting to access a stale value from <${name}> that could possibly be undefined. This may occur because you are reading the accessor returned from the component at a time where it has already been unmounted. We recommend cleaning up any stale timers or async, or reading from the initial condition.` ;
 function For(props) {
   const fallback = "fallback" in props && {
     fallback: () => props.fallback
   };
-  return createMemo(
-    mapArray(() => props.each, props.children, fallback || undefined),
-    undefined,
-    {
-      name: "value"
-    }
-  );
+  return createMemo(mapArray(() => props.each, props.children, fallback || undefined), undefined, {
+    name: "value"
+  }) ;
 }
 function Index(props) {
   const fallback = "fallback" in props && {
     fallback: () => props.fallback
   };
-  return createMemo(
-    indexArray(() => props.each, props.children, fallback || undefined),
-    undefined,
-    {
-      name: "value"
-    }
-  );
+  return createMemo(indexArray(() => props.each, props.children, fallback || undefined), undefined, {
+    name: "value"
+  }) ;
 }
 function Show(props) {
   const keyed = props.keyed;
   const condition = createMemo(() => props.when, undefined, {
-    equals: (a, b) => (keyed ? a === b : !a === !b),
+    equals: (a, b) => keyed ? a === b : !a === !b,
     name: "condition"
-  });
-  return createMemo(
-    () => {
-      const c = condition();
-      if (c) {
-        const child = props.children;
-        const fn = typeof child === "function" && child.length > 0;
-        return fn
-          ? untrack(() =>
-              child(
-                keyed
-                  ? c
-                  : () => {
-                      if (!untrack(condition)) throw narrowedError("Show");
-                      return props.when;
-                    }
-              )
-            )
-          : child;
-      }
-      return props.fallback;
-    },
-    undefined,
-    {
-      name: "value"
+  } );
+  return createMemo(() => {
+    const c = condition();
+    if (c) {
+      const child = props.children;
+      const fn = typeof child === "function" && child.length > 0;
+      return fn ? untrack(() => child(keyed ? c : () => {
+        if (!untrack(condition)) throw narrowedError("Show");
+        return props.when;
+      })) : child;
     }
-  );
+    return props.fallback;
+  }, undefined, {
+    name: "value"
+  } );
 }
 function Switch(props) {
   let keyed = false;
   const equals = (a, b) => (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];
   const conditions = children(() => props.children),
-    evalConditions = createMemo(
-      () => {
-        let conds = conditions();
-        if (!Array.isArray(conds)) conds = [conds];
-        for (let i = 0; i < conds.length; i++) {
-          const c = conds[i].when;
-          if (c) {
-            keyed = !!conds[i].keyed;
-            return [i, c, conds[i]];
-          }
+    evalConditions = createMemo(() => {
+      let conds = conditions();
+      if (!Array.isArray(conds)) conds = [conds];
+      for (let i = 0; i < conds.length; i++) {
+        const c = conds[i].when;
+        if (c) {
+          keyed = !!conds[i].keyed;
+          return [i, c, conds[i]];
         }
-        return [-1];
-      },
-      undefined,
-      {
-        equals,
-        name: "eval conditions"
       }
-    );
-  return createMemo(
-    () => {
-      const [index, when, cond] = evalConditions();
-      if (index < 0) return props.fallback;
-      const c = cond.children;
-      const fn = typeof c === "function" && c.length > 0;
-      return fn
-        ? untrack(() =>
-            c(
-              keyed
-                ? when
-                : () => {
-                    if (untrack(evalConditions)[0] !== index) throw narrowedError("Match");
-                    return cond.when;
-                  }
-            )
-          )
-        : c;
-    },
-    undefined,
-    {
-      name: "value"
-    }
-  );
+      return [-1];
+    }, undefined, {
+      equals,
+      name: "eval conditions"
+    } );
+  return createMemo(() => {
+    const [index, when, cond] = evalConditions();
+    if (index < 0) return props.fallback;
+    const c = cond.children;
+    const fn = typeof c === "function" && c.length > 0;
+    return fn ? untrack(() => c(keyed ? when : () => {
+      if (untrack(evalConditions)[0] !== index) throw narrowedError("Match");
+      return cond.when;
+    })) : c;
+  }, undefined, {
+    name: "value"
+  } );
 }
 function Match(props) {
   return props;
@@ -1734,34 +1559,28 @@ function resetErrorBoundaries() {
 }
 function ErrorBoundary(props) {
   let err;
-  if (sharedConfig.context && sharedConfig.load)
-    err = sharedConfig.load(sharedConfig.getContextId());
+  if (sharedConfig.context && sharedConfig.load) err = sharedConfig.load(sharedConfig.getContextId());
   const [errored, setErrored] = createSignal(err, {
     name: "errored"
-  });
+  } );
   Errors || (Errors = new Set());
   Errors.add(setErrored);
   onCleanup(() => Errors.delete(setErrored));
-  return createMemo(
-    () => {
-      let e;
-      if ((e = errored())) {
-        const f = props.fallback;
-        if (typeof f !== "function" || f.length == 0) console.error(e);
-        return typeof f === "function" && f.length ? untrack(() => f(e, () => setErrored())) : f;
-      }
-      return catchError(() => props.children, setErrored);
-    },
-    undefined,
-    {
-      name: "value"
+  return createMemo(() => {
+    let e;
+    if (e = errored()) {
+      const f = props.fallback;
+      if ((typeof f !== "function" || f.length == 0)) console.error(e);
+      return typeof f === "function" && f.length ? untrack(() => f(e, () => setErrored())) : f;
     }
-  );
+    return catchError(() => props.children, setErrored);
+  }, undefined, {
+    name: "value"
+  } );
 }
 
-const suspenseListEquals = (a, b) =>
-  a.showContent === b.showContent && a.showFallback === b.showFallback;
-const SuspenseListContext = /* #__PURE__ */ createContext();
+const suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;
+const SuspenseListContext = /* #__PURE__ */createContext();
 function SuspenseList(props) {
   let [wrapper, setWrapper] = createSignal(() => ({
       inFallback: false
@@ -1772,51 +1591,51 @@ function SuspenseList(props) {
   if (listContext) {
     show = listContext.register(createMemo(() => wrapper()().inFallback));
   }
-  const resolved = createMemo(
-    prev => {
-      const reveal = props.revealOrder,
-        tail = props.tail,
-        { showContent = true, showFallback = true } = show ? show() : {},
-        reg = registry(),
-        reverse = reveal === "backwards";
-      if (reveal === "together") {
-        const all = reg.every(inFallback => !inFallback());
-        const res = reg.map(() => ({
-          showContent: all && showContent,
+  const resolved = createMemo(prev => {
+    const reveal = props.revealOrder,
+      tail = props.tail,
+      {
+        showContent = true,
+        showFallback = true
+      } = show ? show() : {},
+      reg = registry(),
+      reverse = reveal === "backwards";
+    if (reveal === "together") {
+      const all = reg.every(inFallback => !inFallback());
+      const res = reg.map(() => ({
+        showContent: all && showContent,
+        showFallback
+      }));
+      res.inFallback = !all;
+      return res;
+    }
+    let stop = false;
+    let inFallback = prev.inFallback;
+    const res = [];
+    for (let i = 0, len = reg.length; i < len; i++) {
+      const n = reverse ? len - i - 1 : i,
+        s = reg[n]();
+      if (!stop && !s) {
+        res[n] = {
+          showContent,
           showFallback
-        }));
-        res.inFallback = !all;
-        return res;
-      }
-      let stop = false;
-      let inFallback = prev.inFallback;
-      const res = [];
-      for (let i = 0, len = reg.length; i < len; i++) {
-        const n = reverse ? len - i - 1 : i,
-          s = reg[n]();
-        if (!stop && !s) {
-          res[n] = {
-            showContent,
-            showFallback
-          };
-        } else {
-          const next = !stop;
-          if (next) inFallback = true;
-          res[n] = {
-            showContent: next,
-            showFallback: !tail || (next && tail === "collapsed") ? showFallback : false
-          };
-          stop = true;
-        }
+        };
+      } else {
+        const next = !stop;
+        if (next) inFallback = true;
+        res[n] = {
+          showContent: next,
+          showFallback: !tail || next && tail === "collapsed" ? showFallback : false
+        };
+        stop = true;
       }
-      if (!stop) inFallback = false;
-      res.inFallback = inFallback;
-      return res;
-    },
-    {
-      inFallback: false
     }
-  );
+    if (!stop) inFallback = false;
+    res.inFallback = inFallback;
+    return res;
+  }, {
+    inFallback: false
+  });
   setWrapper(() => resolved);
   return createComponent(SuspenseListContext.Provider, {
     value: {
@@ -1861,27 +1680,23 @@ function Suspense(props) {
     const key = sharedConfig.getContextId();
     let ref = sharedConfig.load(key);
     if (ref) {
-      if (typeof ref !== "object" || ref.status !== "success") p = ref;
-      else sharedConfig.gather(key);
+      if (typeof ref !== "object" || ref.status !== "success") p = ref;else sharedConfig.gather(key);
     }
     if (p && p !== "$$f") {
       const [s, set] = createSignal(undefined, {
         equals: false
       });
       flicker = s;
-      p.then(
-        () => {
-          if (sharedConfig.done) return set();
-          sharedConfig.gather(key);
-          setHydrateContext(ctx);
-          set();
-          setHydrateContext();
-        },
-        err => {
-          error = err;
-          set();
-        }
-      );
+      p.then(() => {
+        if (sharedConfig.done) return set();
+        sharedConfig.gather(key);
+        setHydrateContext(ctx);
+        set();
+        setHydrateContext();
+      }, err => {
+        error = err;
+        set();
+      });
     }
   }
   const listContext = useContext(SuspenseListContext);
@@ -1896,14 +1711,17 @@ function Suspense(props) {
         ctx = sharedConfig.context;
         if (flicker) {
           flicker();
-          return (flicker = undefined);
+          return flicker = undefined;
         }
         if (ctx && p === "$$f") setHydrateContext();
         const rendered = createMemo(() => props.children);
         return createMemo(prev => {
           const inFallback = store.inFallback(),
-            { showContent = true, showFallback = true } = show ? show() : {};
-          if ((!inFallback || (p && p !== "$$f")) && showContent) {
+            {
+              showContent = true,
+              showFallback = true
+            } = show ? show() : {};
+          if ((!inFallback || p && p !== "$$f") && showContent) {
             store.resolved = true;
             dispose && dispose();
             dispose = ctx = p = undefined;
@@ -1930,71 +1748,20 @@ function Suspense(props) {
 }
 
 const DEV = {
+  version: "1.9.3",
+  getOwner: getOwner,
+  getListener: getListener,
+  $PROXY: $PROXY,
+  $DEVCOMP: $DEVCOMP,
+  $TRACK: $TRACK,
   hooks: DevHooks,
-  writeSignal,
-  registerGraph
-};
+  readSignal: readSignal,
+  writeSignal: writeSignal,
+  registerGraph: registerGraph,
+  sharedConfig: sharedConfig
+} ;
 if (globalThis) {
-  if (!globalThis.Solid$$) globalThis.Solid$$ = true;
-  else
-    console.warn(
-      "You appear to have multiple instances of Solid. This can lead to unexpected behavior."
-    );
+  if (!globalThis.Solid$$) globalThis.Solid$$ = DEV;else console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior.");
 }
 
-export {
-  $DEVCOMP,
-  $PROXY,
-  $TRACK,
-  DEV,
-  ErrorBoundary,
-  For,
-  Index,
-  Match,
-  Show,
-  Suspense,
-  SuspenseList,
-  Switch,
-  batch,
-  cancelCallback,
-  catchError,
-  children,
-  createComponent,
-  createComputed,
-  createContext,
-  createDeferred,
-  createEffect,
-  createMemo,
-  createReaction,
-  createRenderEffect,
-  createResource,
-  createRoot,
-  createSelector,
-  createSignal,
-  createUniqueId,
-  enableExternalSource,
-  enableHydration,
-  enableScheduling,
-  equalFn,
-  from,
-  getListener,
-  getOwner,
-  indexArray,
-  lazy,
-  mapArray,
-  mergeProps,
-  observable,
-  on,
-  onCleanup,
-  onError,
-  onMount,
-  requestCallback,
-  resetErrorBoundaries,
-  runWithOwner,
-  sharedConfig,
-  splitProps,
-  startTransition,
-  untrack,
-  useContext,
-  useTransition
-};
+export { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, catchError, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };
diff --git a/dist/server.cjs b/dist/server.cjs
index 860868f23a4c79f57778b3a08701d4a3d9e2914b..5cc7743f4e88ad6bf74a138f9d076dd29a983e62 100644
--- a/dist/server.cjs
+++ b/dist/server.cjs
@@ -470,15 +470,10 @@ function ErrorBoundary(props) {
 const SuspenseContext = createContext();
 let resourceContext = null;
 function createResource(source, fetcher, options = {}) {
-  if (arguments.length === 2) {
-    if (typeof fetcher === "object") {
-      options = fetcher;
-      fetcher = source;
-      source = true;
-    }
-  } else if (arguments.length === 1) {
-    fetcher = source;
+  if (typeof fetcher !== "function") {
     source = true;
+    fetcher = source;
+    options = fetcher || {};
   }
   const contexts = new Set();
   const id = sharedConfig.getNextContextId();
diff --git a/dist/server.js b/dist/server.js
index ef26b85268ff3a74511650bf3222ff411e679c9b..d770f94a94e02a11f0214ffaaddfc79567c27f94 100644
--- a/dist/server.js
+++ b/dist/server.js
@@ -17,7 +17,7 @@ function handleError(err, owner = Owner) {
   try {
     for (const f of fns) f(error);
   } catch (e) {
-    handleError(e, (owner && owner.owner) || null);
+    handleError(e, owner && owner.owner || null);
   }
 }
 const UNOWNED = {
@@ -35,23 +35,19 @@ function createOwner() {
     cleanups: null
   };
   if (Owner) {
-    if (!Owner.owned) Owner.owned = [o];
-    else Owner.owned.push(o);
+    if (!Owner.owned) Owner.owned = [o];else Owner.owned.push(o);
   }
   return o;
 }
 function createRoot(fn, detachedOwner) {
   const owner = Owner,
     current = detachedOwner === undefined ? owner : detachedOwner,
-    root =
-      fn.length === 0
-        ? UNOWNED
-        : {
-            context: current ? current.context : null,
-            owner: current,
-            owned: null,
-            cleanups: null
-          };
+    root = fn.length === 0 ? UNOWNED : {
+      context: current ? current.context : null,
+      owner: current,
+      owned: null,
+      cleanups: null
+    };
   Owner = root;
   let result;
   try {
@@ -64,12 +60,9 @@ function createRoot(fn, detachedOwner) {
   return result;
 }
 function createSignal(value, options) {
-  return [
-    () => value,
-    v => {
-      return (value = typeof v === "function" ? v(value) : v);
-    }
-  ];
+  return [() => value, v => {
+    return value = typeof v === "function" ? v(value) : v;
+  }];
 }
 function createComputed(fn, value) {
   Owner = createOwner();
@@ -126,8 +119,7 @@ function on(deps, fn, options = {}) {
 function onMount(fn) {}
 function onCleanup(fn) {
   if (Owner) {
-    if (!Owner.cleanups) Owner.cleanups = [fn];
-    else Owner.cleanups.push(fn);
+    if (!Owner.cleanups) Owner.cleanups = [fn];else Owner.cleanups.push(fn);
   }
   return fn;
 }
@@ -168,9 +160,7 @@ function createContext(defaultValue) {
   };
 }
 function useContext(context) {
-  return Owner && Owner.context && Owner.context[context.id] !== undefined
-    ? Owner.context[context.id]
-    : context.defaultValue;
+  return Owner && Owner.context && Owner.context[context.id] !== undefined ? Owner.context[context.id] : context.defaultValue;
 }
 function getOwner() {
   return Owner;
@@ -247,8 +237,7 @@ function observable(input) {
       if (!(observer instanceof Object) || observer == null) {
         throw new TypeError("Expected the observer to be an object.");
       }
-      const handler =
-        typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
+      const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
       if (!handler) {
         return {
           unsubscribe() {}
@@ -277,7 +266,7 @@ function from(producer) {
   const [s, set] = createSignal(undefined);
   if ("subscribe" in producer) {
     const unsub = producer.subscribe(v => set(() => v));
-    onCleanup(() => ("unsubscribe" in unsub ? unsub.unsubscribe() : unsub()));
+    onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
   } else {
     const clean = producer(set);
     onCleanup(clean);
@@ -320,7 +309,7 @@ function resolveSSRNode(node) {
     let mapped = "";
     for (let i = 0, len = node.length; i < len; i++) {
       if (typeof prev !== "object" && typeof node[i] !== "object") mapped += `<!--!$-->`;
-      mapped += resolveSSRNode((prev = node[i]));
+      mapped += resolveSSRNode(prev = node[i]);
     }
     return mapped;
   }
@@ -335,8 +324,7 @@ const sharedConfig = {
     return getContextId(this.context.count);
   },
   getNextContextId() {
-    if (!this.context)
-      throw new Error(`getNextContextId cannot be used under non-hydrating context`);
+    if (!this.context) throw new Error(`getNextContextId cannot be used under non-hydrating context`);
     return getContextId(this.context.count++);
   }
 };
@@ -349,13 +337,11 @@ function setHydrateContext(context) {
   sharedConfig.context = context;
 }
 function nextHydrateContext() {
-  return sharedConfig.context
-    ? {
-        ...sharedConfig.context,
-        id: sharedConfig.getNextContextId(),
-        count: 0
-      }
-    : undefined;
+  return sharedConfig.context ? {
+    ...sharedConfig.context,
+    id: sharedConfig.getNextContextId(),
+    count: 0
+  } : undefined;
 }
 function createUniqueId() {
   return sharedConfig.getNextContextId();
@@ -430,11 +416,7 @@ function Index(props) {
 }
 function Show(props) {
   let c;
-  return props.when
-    ? typeof (c = props.children) === "function"
-      ? c(props.keyed ? props.when : () => props.when)
-      : c
-    : props.fallback || "";
+  return props.when ? typeof (c = props.children) === "function" ? c(props.keyed ? props.when : () => props.when) : c : props.fallback || "";
 }
 function Switch(props) {
   let conditions = props.children;
@@ -471,14 +453,11 @@ function ErrorBoundary(props) {
   }
   createMemo(() => {
     clean = Owner;
-    return catchError(
-      () => (res = props.children),
-      err => {
-        error = err;
-        !sync && ctx.replace("e" + id, displayFallback);
-        sync = true;
-      }
-    );
+    return catchError(() => res = props.children, err => {
+      error = err;
+      !sync && ctx.replace("e" + id, displayFallback);
+      sync = true;
+    });
   });
   if (error) return displayFallback();
   sync = false;
@@ -489,15 +468,10 @@ function ErrorBoundary(props) {
 const SuspenseContext = createContext();
 let resourceContext = null;
 function createResource(source, fetcher, options = {}) {
-  if (arguments.length === 2) {
-    if (typeof fetcher === "object") {
-      options = fetcher;
-      fetcher = source;
-      source = true;
-    }
-  } else if (arguments.length === 1) {
-    fetcher = source;
+  if (typeof fetcher !== "function") {
     source = true;
+    fetcher = source;
+    options = fetcher || {};
   }
   const contexts = new Set();
   const id = sharedConfig.getNextContextId();
@@ -508,17 +482,13 @@ function createResource(source, fetcher, options = {}) {
   if (sharedConfig.context.async && options.ssrLoadFrom !== "initial") {
     resource = sharedConfig.context.resources[id] || (sharedConfig.context.resources[id] = {});
     if (resource.ref) {
-      if (!resource.data && !resource.ref[0].loading && !resource.ref[0].error)
-        resource.ref[1].refetch();
+      if (!resource.data && !resource.ref[0].loading && !resource.ref[0].error) resource.ref[1].refetch();
       return resource.ref;
     }
   }
   const read = () => {
     if (error) throw error;
-    const resolved =
-      options.ssrLoadFrom !== "initial" &&
-      sharedConfig.context.async &&
-      "data" in sharedConfig.context.resources[id];
+    const resolved = options.ssrLoadFrom !== "initial" && sharedConfig.context.async && "data" in sharedConfig.context.resources[id];
     if (!resolved && resourceContext) resourceContext.push(id);
     if (!resolved && read.loading) {
       const ctx = useContext(SuspenseContext);
@@ -539,7 +509,7 @@ function createResource(source, fetcher, options = {}) {
   });
   function load() {
     const ctx = sharedConfig.context;
-    if (!ctx.async) return (read.loading = !!(typeof source === "function" ? source() : source));
+    if (!ctx.async) return read.loading = !!(typeof source === "function" ? source() : source);
     if (ctx.resources && id in ctx.resources && "data" in ctx.resources[id]) {
       value = ctx.resources[id].data;
       return;
@@ -561,23 +531,21 @@ function createResource(source, fetcher, options = {}) {
     if (p != undefined && typeof p === "object" && "then" in p) {
       read.loading = true;
       read.state = "pending";
-      p = p
-        .then(res => {
-          read.loading = false;
-          read.state = "ready";
-          ctx.resources[id].data = res;
-          p = null;
-          notifySuspense(contexts);
-          return res;
-        })
-        .catch(err => {
-          read.loading = false;
-          read.state = "errored";
-          read.error = error = castError(err);
-          p = null;
-          notifySuspense(contexts);
-          throw error;
-        });
+      p = p.then(res => {
+        read.loading = false;
+        read.state = "ready";
+        ctx.resources[id].data = res;
+        p = null;
+        notifySuspense(contexts);
+        return res;
+      }).catch(err => {
+        read.loading = false;
+        read.state = "errored";
+        read.error = error = castError(err);
+        p = null;
+        notifySuspense(contexts);
+        throw error;
+      });
       if (ctx.serialize) ctx.serialize(id, p, options.deferStream);
       return p;
     }
@@ -587,20 +555,17 @@ function createResource(source, fetcher, options = {}) {
     return ctx.resources[id].data;
   }
   if (options.ssrLoadFrom !== "initial") load();
-  return (resource.ref = [
-    read,
-    {
-      refetch: load,
-      mutate: v => (value = v)
-    }
-  ]);
+  return resource.ref = [read, {
+    refetch: load,
+    mutate: v => value = v
+  }];
 }
 function lazy(fn) {
   let p;
   let load = id => {
     if (!p) {
       p = fn();
-      p.then(mod => (p.resolved = mod.default));
+      p.then(mod => p.resolved = mod.default);
       if (id) sharedConfig.context.lazy[id] = p;
     }
     return p;
@@ -609,8 +574,7 @@ function lazy(fn) {
   const wrap = props => {
     const id = sharedConfig.context.id;
     let ref = sharedConfig.context.lazy[id];
-    if (ref) p = ref;
-    else load(id);
+    if (ref) p = ref;else load(id);
     if (p.resolved) return p.resolved(props);
     const ctx = useContext(SuspenseContext);
     const track = {
@@ -622,12 +586,10 @@ function lazy(fn) {
       contexts.add(ctx);
     }
     if (sharedConfig.context.async) {
-      sharedConfig.context.block(
-        p.then(() => {
-          track.loading = false;
-          notifySuspense(contexts);
-        })
-      );
+      sharedConfig.context.block(p.then(() => {
+        track.loading = false;
+        notifySuspense(contexts);
+      }));
     }
     return "";
   };
@@ -655,12 +617,9 @@ function startTransition(fn) {
   fn();
 }
 function useTransition() {
-  return [
-    () => false,
-    fn => {
-      fn();
-    }
-  ];
+  return [() => false, fn => {
+    fn();
+  }];
 }
 function SuspenseList(props) {
   return props.children;
@@ -670,17 +629,15 @@ function Suspense(props) {
   const ctx = sharedConfig.context;
   const id = sharedConfig.getContextId();
   const o = createOwner();
-  const value =
-    ctx.suspense[id] ||
-    (ctx.suspense[id] = {
-      resources: new Map(),
-      completed: () => {
-        const res = runSuspense();
-        if (suspenseComplete(value)) {
-          done(resolveSSRNode(res));
-        }
+  const value = ctx.suspense[id] || (ctx.suspense[id] = {
+    resources: new Map(),
+    completed: () => {
+      const res = runSuspense();
+      if (suspenseComplete(value)) {
+        done(resolveSSRNode(res));
       }
-    });
+    }
+  });
   function suspenseError(err) {
     if (!done || !done(undefined, err)) {
       runWithOwner(o.owner, () => {
@@ -694,14 +651,12 @@ function Suspense(props) {
       count: 0
     });
     cleanNode(o);
-    return runWithOwner(o, () =>
-      createComponent(SuspenseContext.Provider, {
-        value,
-        get children() {
-          return catchError(() => props.children, suspenseError);
-        }
-      })
-    );
+    return runWithOwner(o, () => createComponent(SuspenseContext.Provider, {
+      value,
+      get children() {
+        return catchError(() => props.children, suspenseError);
+      }
+    }));
   }
   const res = runSuspense();
   if (suspenseComplete(value)) {
@@ -733,58 +688,4 @@ function Suspense(props) {
   }, suspenseError);
 }
 
-export {
-  $DEVCOMP,
-  $PROXY,
-  $TRACK,
-  DEV,
-  ErrorBoundary,
-  For,
-  Index,
-  Match,
-  Show,
-  Suspense,
-  SuspenseList,
-  Switch,
-  batch,
-  catchError,
-  children,
-  createComponent,
-  createComputed,
-  createContext,
-  createDeferred,
-  createEffect,
-  createMemo,
-  createReaction,
-  createRenderEffect,
-  createResource,
-  createRoot,
-  createSelector,
-  createSignal,
-  createUniqueId,
-  enableExternalSource,
-  enableHydration,
-  enableScheduling,
-  equalFn,
-  from,
-  getListener,
-  getOwner,
-  indexArray,
-  lazy,
-  mapArray,
-  mergeProps,
-  observable,
-  on,
-  onCleanup,
-  onError,
-  onMount,
-  requestCallback,
-  resetErrorBoundaries,
-  runWithOwner,
-  sharedConfig,
-  splitProps,
-  startTransition,
-  untrack,
-  useContext,
-  useTransition
-};
+export { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, catchError, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };
diff --git a/dist/solid.cjs b/dist/solid.cjs
index 9277d3a27c0822b05f968f0ed137655a79cd7158..c07278b29b76d24c9133f5202b5c2f1f6a8951ba 100644
--- a/dist/solid.cjs
+++ b/dist/solid.cjs
@@ -257,14 +257,14 @@ function createResource(pSource, pFetcher, pOptions) {
   let source;
   let fetcher;
   let options;
-  if (arguments.length === 2 && typeof pFetcher === "object" || arguments.length === 1) {
-    source = true;
-    fetcher = pSource;
-    options = pFetcher || {};
-  } else {
+  if (typeof pFetcher === "function") {
     source = pSource;
     fetcher = pFetcher;
     options = pOptions || {};
+  } else {
+    source = true;
+    fetcher = pSource;
+    options = pFetcher || {};
   }
   let pr = null,
     initP = NO_INIT,
diff --git a/dist/solid.js b/dist/solid.js
index b9ced44f69369d2db93452cb7fbd9476f411e890..55203e3cf3b0a9973d455df20281b6cfc31e833d 100644
--- a/dist/solid.js
+++ b/dist/solid.js
@@ -52,11 +52,9 @@ function enqueue(taskQueue, task) {
     let m = 0;
     let n = taskQueue.length - 1;
     while (m <= n) {
-      const k = (n + m) >> 1;
+      const k = n + m >> 1;
       const cmp = task.expirationTime - taskQueue[k].expirationTime;
-      if (cmp > 0) m = k + 1;
-      else if (cmp < 0) n = k - 1;
-      else return k;
+      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;
     }
     return m;
   }
@@ -176,14 +174,12 @@ function createRoot(fn, detachedOwner) {
     owner = Owner,
     unowned = fn.length === 0,
     current = detachedOwner === undefined ? owner : detachedOwner,
-    root = unowned
-      ? UNOWNED
-      : {
-          owned: null,
-          cleanups: null,
-          context: current ? current.context : null,
-          owner: current
-        },
+    root = unowned ? UNOWNED : {
+      owned: null,
+      cleanups: null,
+      context: current ? current.context : null,
+      owner: current
+    },
     updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
   Owner = root;
   Listener = null;
@@ -204,8 +200,7 @@ function createSignal(value, options) {
   };
   const setter = value => {
     if (typeof value === "function") {
-      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);
-      else value = value(s.value);
+      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);else value = value(s.value);
     }
     return writeSignal(s, value);
   };
@@ -213,13 +208,11 @@ function createSignal(value, options) {
 }
 function createComputed(fn, value, options) {
   const c = createComputation(fn, value, true, STALE);
-  if (Scheduler && Transition && Transition.running) Updates.push(c);
-  else updateComputation(c);
+  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);
 }
 function createRenderEffect(fn, value, options) {
   const c = createComputation(fn, value, false, STALE);
-  if (Scheduler && Transition && Transition.running) Updates.push(c);
-  else updateComputation(c);
+  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);
 }
 function createEffect(fn, value, options) {
   runEffects = runUserEffects;
@@ -231,15 +224,10 @@ function createEffect(fn, value, options) {
 }
 function createReaction(onInvalidate, options) {
   let fn;
-  const c = createComputation(
-      () => {
-        fn ? fn() : untrack(onInvalidate);
-        fn = undefined;
-      },
-      undefined,
-      false,
-      0
-    ),
+  const c = createComputation(() => {
+      fn ? fn() : untrack(onInvalidate);
+      fn = undefined;
+    }, undefined, false, 0),
     s = SuspenseContext && useContext(SuspenseContext);
   if (s) c.suspense = s;
   c.user = true;
@@ -267,14 +255,14 @@ function createResource(pSource, pFetcher, pOptions) {
   let source;
   let fetcher;
   let options;
-  if ((arguments.length === 2 && typeof pFetcher === "object") || arguments.length === 1) {
-    source = true;
-    fetcher = pSource;
-    options = pFetcher || {};
-  } else {
+  if (typeof pFetcher === "function") {
     source = pSource;
     fetcher = pFetcher;
     options = pOptions || {};
+  } else {
+    source = true;
+    fetcher = pSource;
+    options = pFetcher || {};
   }
   let pr = null,
     initP = NO_INIT,
@@ -292,19 +280,15 @@ function createResource(pSource, pFetcher, pOptions) {
     [state, setState] = createSignal(resolved ? "ready" : "unresolved");
   if (sharedConfig.context) {
     id = sharedConfig.getNextContextId();
-    if (options.ssrLoadFrom === "initial") initP = options.initialValue;
-    else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
+    if (options.ssrLoadFrom === "initial") initP = options.initialValue;else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
   }
   function loadEnd(p, v, error, key) {
     if (pr === p) {
       pr = null;
       key !== undefined && (resolved = true);
-      if ((p === initP || v === initP) && options.onHydrated)
-        queueMicrotask(() =>
-          options.onHydrated(key, {
-            value: v
-          })
-        );
+      if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {
+        value: v
+      }));
       initP = NO_INIT;
       if (Transition && p && loadedUnderTransition) {
         Transition.promises.delete(p);
@@ -335,8 +319,7 @@ function createResource(pSource, pFetcher, pOptions) {
       createComputed(() => {
         track();
         if (pr) {
-          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);
-          else if (!contexts.has(c)) {
+          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);else if (!contexts.has(c)) {
             c.increment();
             contexts.add(c);
           }
@@ -355,35 +338,26 @@ function createResource(pSource, pFetcher, pOptions) {
       return;
     }
     if (Transition && pr) Transition.promises.delete(pr);
-    const p =
-      initP !== NO_INIT
-        ? initP
-        : untrack(() =>
-            fetcher(lookup, {
-              value: value(),
-              refetching
-            })
-          );
+    const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup, {
+      value: value(),
+      refetching
+    }));
     if (!isPromise(p)) {
       loadEnd(pr, p, undefined, lookup);
       return p;
     }
     pr = p;
     if ("value" in p) {
-      if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);
-      else loadEnd(pr, undefined, castError(p.value), lookup);
+      if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);else loadEnd(pr, undefined, castError(p.value), lookup);
       return p;
     }
     scheduled = true;
-    queueMicrotask(() => (scheduled = false));
+    queueMicrotask(() => scheduled = false);
     runUpdates(() => {
       setState(resolved ? "refreshing" : "pending");
       trigger();
     }, false);
-    return p.then(
-      v => loadEnd(p, v, undefined, lookup),
-      e => loadEnd(p, undefined, castError(e), lookup)
-    );
+    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, undefined, castError(e), lookup));
   }
   Object.defineProperties(read, {
     state: {
@@ -407,80 +381,50 @@ function createResource(pSource, pFetcher, pOptions) {
       }
     }
   });
-  if (dynamic) createComputed(() => load(false));
-  else load(false);
-  return [
-    read,
-    {
-      refetch: load,
-      mutate: setValue
-    }
-  ];
+  if (dynamic) createComputed(() => load(false));else load(false);
+  return [read, {
+    refetch: load,
+    mutate: setValue
+  }];
 }
 function createDeferred(source, options) {
   let t,
     timeout = options ? options.timeoutMs : undefined;
-  const node = createComputation(
-    () => {
-      if (!t || !t.fn)
-        t = requestCallback(
-          () => setDeferred(() => node.value),
-          timeout !== undefined
-            ? {
-                timeout
-              }
-            : undefined
-        );
-      return source();
-    },
-    undefined,
-    true
-  );
-  const [deferred, setDeferred] = createSignal(
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
-    options
-  );
+  const node = createComputation(() => {
+    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {
+      timeout
+    } : undefined);
+    return source();
+  }, undefined, true);
+  const [deferred, setDeferred] = createSignal(Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, options);
   updateComputation(node);
-  setDeferred(() =>
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value
-  );
+  setDeferred(() => Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
   return deferred;
 }
 function createSelector(source, fn = equalFn, options) {
   const subs = new Map();
-  const node = createComputation(
-    p => {
-      const v = source();
-      for (const [key, val] of subs.entries())
-        if (fn(key, v) !== fn(key, p)) {
-          for (const c of val.values()) {
-            c.state = STALE;
-            if (c.pure) Updates.push(c);
-            else Effects.push(c);
-          }
-        }
-      return v;
-    },
-    undefined,
-    true,
-    STALE
-  );
+  const node = createComputation(p => {
+    const v = source();
+    for (const [key, val] of subs.entries()) if (fn(key, v) !== fn(key, p)) {
+      for (const c of val.values()) {
+        c.state = STALE;
+        if (c.pure) Updates.push(c);else Effects.push(c);
+      }
+    }
+    return v;
+  }, undefined, true, STALE);
   updateComputation(node);
   return key => {
     const listener = Listener;
     if (listener) {
       let l;
-      if ((l = subs.get(key))) l.add(listener);
-      else subs.set(key, (l = new Set([listener])));
+      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));
       onCleanup(() => {
         l.delete(listener);
         !l.size && subs.delete(key);
       });
     }
-    return fn(
-      key,
-      Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value
-    );
+    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
   };
 }
 function batch(fn) {
@@ -520,9 +464,7 @@ function onMount(fn) {
   createEffect(() => untrack(fn));
 }
 function onCleanup(fn) {
-  if (Owner === null);
-  else if (Owner.cleanups === null) Owner.cleanups = [fn];
-  else Owner.cleanups.push(fn);
+  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);
   return fn;
 }
 function catchError(fn, handler) {
@@ -576,17 +518,15 @@ function startTransition(fn) {
     Owner = o;
     let t;
     if (Scheduler || SuspenseContext) {
-      t =
-        Transition ||
-        (Transition = {
-          sources: new Set(),
-          effects: [],
-          promises: new Set(),
-          disposed: new Set(),
-          queue: new Set(),
-          running: true
-        });
-      t.done || (t.done = new Promise(res => (t.resolve = res)));
+      t = Transition || (Transition = {
+        sources: new Set(),
+        effects: [],
+        promises: new Set(),
+        disposed: new Set(),
+        queue: new Set(),
+        running: true
+      });
+      t.done || (t.done = new Promise(res => t.resolve = res));
       t.running = true;
     }
     runUpdates(fn, false);
@@ -594,7 +534,7 @@ function startTransition(fn) {
     return t ? t.done : undefined;
   });
 }
-const [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);
+const [transPending, setTransPending] = /*@__PURE__*/createSignal(false);
 function useTransition() {
   return [transPending, startTransition];
 }
@@ -612,9 +552,7 @@ function createContext(defaultValue, options) {
 }
 function useContext(context) {
   let value;
-  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined
-    ? value
-    : context.defaultValue;
+  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined ? value : context.defaultValue;
 }
 function children(fn) {
   const children = createMemo(fn);
@@ -631,7 +569,10 @@ function getSuspenseContext() {
 }
 function enableExternalSource(factory, untrack = fn => fn()) {
   if (ExternalSourceConfig) {
-    const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;
+    const {
+      factory: oldFactory,
+      untrack: oldUntrack
+    } = ExternalSourceConfig;
     ExternalSourceConfig = {
       factory: (fn, trigger) => {
         const oldSource = oldFactory(fn, trigger);
@@ -656,8 +597,7 @@ function enableExternalSource(factory, untrack = fn => fn()) {
 function readSignal() {
   const runningTransition = Transition && Transition.running;
   if (this.sources && (runningTransition ? this.tState : this.state)) {
-    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
-    else {
+    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);else {
       const updates = Updates;
       Updates = null;
       runUpdates(() => lookUpstream(this), false);
@@ -685,12 +625,11 @@ function readSignal() {
   return this.value;
 }
 function writeSignal(node, value, isComp) {
-  let current =
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
+  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
   if (!node.comparator || !node.comparator(current, value)) {
     if (Transition) {
       const TransitionRunning = Transition.running;
-      if (TransitionRunning || (!isComp && Transition.sources.has(node))) {
+      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
         Transition.sources.add(node);
         node.tValue = value;
       }
@@ -703,16 +642,14 @@ function writeSignal(node, value, isComp) {
           const TransitionRunning = Transition && Transition.running;
           if (TransitionRunning && Transition.disposed.has(o)) continue;
           if (TransitionRunning ? !o.tState : !o.state) {
-            if (o.pure) Updates.push(o);
-            else Effects.push(o);
+            if (o.pure) Updates.push(o);else Effects.push(o);
             if (o.observers) markDownstream(o);
           }
-          if (!TransitionRunning) o.state = STALE;
-          else o.tState = STALE;
+          if (!TransitionRunning) o.state = STALE;else o.tState = STALE;
         }
         if (Updates.length > 10e5) {
           Updates = [];
-          if (false);
+          if (false) ;
           throw new Error();
         }
       }, false);
@@ -724,11 +661,7 @@ function updateComputation(node) {
   if (!node.fn) return;
   cleanNode(node);
   const time = ExecCount;
-  runComputation(
-    node,
-    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
-    time
-  );
+  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
   if (Transition && !Transition.running && Transition.sources.has(node)) {
     queueMicrotask(() => {
       runUpdates(() => {
@@ -793,14 +726,11 @@ function createComputation(fn, init, pure, state = STALE, options) {
     c.state = 0;
     c.tState = state;
   }
-  if (Owner === null);
-  else if (Owner !== UNOWNED) {
+  if (Owner === null) ;else if (Owner !== UNOWNED) {
     if (Transition && Transition.running && Owner.pure) {
-      if (!Owner.tOwned) Owner.tOwned = [c];
-      else Owner.tOwned.push(c);
+      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);
     } else {
-      if (!Owner.owned) Owner.owned = [c];
-      else Owner.owned.push(c);
+      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);
     }
   }
   if (ExternalSourceConfig && c.fn) {
@@ -851,8 +781,7 @@ function runUpdates(fn, init) {
   if (Updates) return fn();
   let wait = false;
   if (!init) Updates = [];
-  if (Effects) wait = true;
-  else Effects = [];
+  if (Effects) wait = true;else Effects = [];
   ExecCount++;
   try {
     const res = fn();
@@ -866,8 +795,7 @@ function runUpdates(fn, init) {
 }
 function completeUpdates(wait) {
   if (Updates) {
-    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
-    else runQueue(Updates);
+    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);
     Updates = null;
   }
   if (wait) return;
@@ -935,8 +863,7 @@ function runUserEffects(queue) {
     userLength = 0;
   for (i = 0; i < queue.length; i++) {
     const e = queue[i];
-    if (!e.user) runTop(e);
-    else queue[userLength++] = e;
+    if (!e.user) runTop(e);else queue[userLength++] = e;
   }
   if (sharedConfig.context) {
     if (sharedConfig.count) {
@@ -955,15 +882,13 @@ function runUserEffects(queue) {
 }
 function lookUpstream(node, ignore) {
   const runningTransition = Transition && Transition.running;
-  if (runningTransition) node.tState = 0;
-  else node.state = 0;
+  if (runningTransition) node.tState = 0;else node.state = 0;
   for (let i = 0; i < node.sources.length; i += 1) {
     const source = node.sources[i];
     if (source.sources) {
       const state = runningTransition ? source.tState : source.state;
       if (state === STALE) {
-        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
-          runTop(source);
+        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
       } else if (state === PENDING) lookUpstream(source, ignore);
     }
   }
@@ -973,10 +898,8 @@ function markDownstream(node) {
   for (let i = 0; i < node.observers.length; i += 1) {
     const o = node.observers[i];
     if (runningTransition ? !o.tState : !o.state) {
-      if (runningTransition) o.tState = PENDING;
-      else o.state = PENDING;
-      if (o.pure) Updates.push(o);
-      else Effects.push(o);
+      if (runningTransition) o.tState = PENDING;else o.state = PENDING;
+      if (o.pure) Updates.push(o);else Effects.push(o);
       o.observers && markDownstream(o);
     }
   }
@@ -1013,8 +936,7 @@ function cleanNode(node) {
     for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
     node.cleanups = null;
   }
-  if (Transition && Transition.running) node.tState = 0;
-  else node.state = 0;
+  if (Transition && Transition.running) node.tState = 0;else node.state = 0;
 }
 function reset(node, top) {
   if (!top) {
@@ -1035,21 +957,19 @@ function runErrors(err, fns, owner) {
   try {
     for (const f of fns) f(err);
   } catch (e) {
-    handleError(e, (owner && owner.owner) || null);
+    handleError(e, owner && owner.owner || null);
   }
 }
 function handleError(err, owner = Owner) {
   const fns = ERROR && owner && owner.context && owner.context[ERROR];
   const error = castError(err);
   if (!fns) throw error;
-  if (Effects)
-    Effects.push({
-      fn() {
-        runErrors(error, fns, owner);
-      },
-      state: STALE
-    });
-  else runErrors(error, fns, owner);
+  if (Effects) Effects.push({
+    fn() {
+      runErrors(error, fns, owner);
+    },
+    state: STALE
+  });else runErrors(error, fns, owner);
 }
 function resolveChildren(children) {
   if (typeof children === "function" && !children.length) return resolveChildren(children());
@@ -1066,24 +986,19 @@ function resolveChildren(children) {
 function createProvider(id, options) {
   return function provider(props) {
     let res;
-    createRenderEffect(
-      () =>
-        (res = untrack(() => {
-          Owner.context = {
-            ...Owner.context,
-            [id]: props.value
-          };
-          return children(() => props.children);
-        })),
-      undefined
-    );
+    createRenderEffect(() => res = untrack(() => {
+      Owner.context = {
+        ...Owner.context,
+        [id]: props.value
+      };
+      return children(() => props.children);
+    }), undefined);
     return res;
   };
 }
 function onError(fn) {
   ERROR || (ERROR = Symbol("error"));
-  if (Owner === null);
-  else if (Owner.context === null || !Owner.context[ERROR]) {
+  if (Owner === null) ;else if (Owner.context === null || !Owner.context[ERROR]) {
     Owner.context = {
       ...Owner.context,
       [ERROR]: [fn]
@@ -1112,8 +1027,7 @@ function observable(input) {
       if (!(observer instanceof Object) || observer == null) {
         throw new TypeError("Expected the observer to be an object.");
       }
-      const handler =
-        typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
+      const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
       if (!handler) {
         return {
           unsubscribe() {}
@@ -1144,7 +1058,7 @@ function from(producer) {
   });
   if ("subscribe" in producer) {
     const unsub = producer.subscribe(v => set(() => v));
-    onCleanup(() => ("unsubscribe" in unsub ? unsub.unsubscribe() : unsub()));
+    onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
   } else {
     const clean = producer(set);
     onCleanup(clean);
@@ -1188,7 +1102,8 @@ function mapArray(list, mapFn, options = {}) {
           });
           len = 1;
         }
-      } else if (len === 0) {
+      }
+      else if (len === 0) {
         mapped = new Array(newLen);
         for (j = 0; j < newLen; j++) {
           items[j] = newItems[j];
@@ -1199,16 +1114,8 @@ function mapArray(list, mapFn, options = {}) {
         temp = new Array(newLen);
         tempdisposers = new Array(newLen);
         indexes && (tempIndexes = new Array(newLen));
-        for (
-          start = 0, end = Math.min(len, newLen);
-          start < end && items[start] === newItems[start];
-          start++
-        );
-        for (
-          end = len - 1, newEnd = newLen - 1;
-          end >= start && newEnd >= start && items[end] === newItems[newEnd];
-          end--, newEnd--
-        ) {
+        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);
+        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
           temp[newEnd] = mapped[end];
           tempdisposers[newEnd] = disposers[end];
           indexes && (tempIndexes[newEnd] = indexes[end]);
@@ -1242,7 +1149,7 @@ function mapArray(list, mapFn, options = {}) {
             }
           } else mapped[j] = createRoot(mapper);
         }
-        mapped = mapped.slice(0, (len = newLen));
+        mapped = mapped.slice(0, len = newLen);
         items = newItems.slice(0);
       }
       return mapped;
@@ -1309,7 +1216,7 @@ function indexArray(list, mapFn, options = {}) {
       }
       len = signals.length = disposers.length = newLen;
       items = newItems.slice(0);
-      return (mapped = mapped.slice(0, len));
+      return mapped = mapped.slice(0, len);
     });
     function mapper(disposer) {
       disposers[i] = disposer;
@@ -1378,33 +1285,29 @@ function mergeProps(...sources) {
   let proxy = false;
   for (let i = 0; i < sources.length; i++) {
     const s = sources[i];
-    proxy = proxy || (!!s && $PROXY in s);
-    sources[i] = typeof s === "function" ? ((proxy = true), createMemo(s)) : s;
+    proxy = proxy || !!s && $PROXY in s;
+    sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
   }
   if (SUPPORTS_PROXY && proxy) {
-    return new Proxy(
-      {
-        get(property) {
-          for (let i = sources.length - 1; i >= 0; i--) {
-            const v = resolveSource(sources[i])[property];
-            if (v !== undefined) return v;
-          }
-        },
-        has(property) {
-          for (let i = sources.length - 1; i >= 0; i--) {
-            if (property in resolveSource(sources[i])) return true;
-          }
-          return false;
-        },
-        keys() {
-          const keys = [];
-          for (let i = 0; i < sources.length; i++)
-            keys.push(...Object.keys(resolveSource(sources[i])));
-          return [...new Set(keys)];
+    return new Proxy({
+      get(property) {
+        for (let i = sources.length - 1; i >= 0; i--) {
+          const v = resolveSource(sources[i])[property];
+          if (v !== undefined) return v;
+        }
+      },
+      has(property) {
+        for (let i = sources.length - 1; i >= 0; i--) {
+          if (property in resolveSource(sources[i])) return true;
         }
+        return false;
       },
-      propTraps
-    );
+      keys() {
+        const keys = [];
+        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
+        return [...new Set(keys)];
+      }
+    }, propTraps);
   }
   const sourcesMap = {};
   const defined = Object.create(null);
@@ -1417,20 +1320,15 @@ function mergeProps(...sources) {
       if (key === "__proto__" || key === "constructor") continue;
       const desc = Object.getOwnPropertyDescriptor(source, key);
       if (!defined[key]) {
-        defined[key] = desc.get
-          ? {
-              enumerable: true,
-              configurable: true,
-              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))
-            }
-          : desc.value !== undefined
-          ? desc
-          : undefined;
+        defined[key] = desc.get ? {
+          enumerable: true,
+          configurable: true,
+          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
+        } : desc.value !== undefined ? desc : undefined;
       } else {
         const sources = sourcesMap[key];
         if (sources) {
-          if (desc.get) sources.push(desc.get.bind(source));
-          else if (desc.value !== undefined) sources.push(() => desc.value);
+          if (desc.get) sources.push(desc.get.bind(source));else if (desc.value !== undefined) sources.push(() => desc.value);
         }
       }
     }
@@ -1440,8 +1338,7 @@ function mergeProps(...sources) {
   for (let i = definedKeys.length - 1; i >= 0; i--) {
     const key = definedKeys[i],
       desc = defined[key];
-    if (desc && desc.get) Object.defineProperty(target, key, desc);
-    else target[key] = desc ? desc.value : undefined;
+    if (desc && desc.get) Object.defineProperty(target, key, desc);else target[key] = desc ? desc.value : undefined;
   }
   return target;
 }
@@ -1449,60 +1346,47 @@ function splitProps(props, ...keys) {
   if (SUPPORTS_PROXY && $PROXY in props) {
     const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
     const res = keys.map(k => {
-      return new Proxy(
-        {
-          get(property) {
-            return k.includes(property) ? props[property] : undefined;
-          },
-          has(property) {
-            return k.includes(property) && property in props;
-          },
-          keys() {
-            return k.filter(property => property in props);
-          }
+      return new Proxy({
+        get(property) {
+          return k.includes(property) ? props[property] : undefined;
         },
-        propTraps
-      );
-    });
-    res.push(
-      new Proxy(
-        {
-          get(property) {
-            return blocked.has(property) ? undefined : props[property];
-          },
-          has(property) {
-            return blocked.has(property) ? false : property in props;
-          },
-          keys() {
-            return Object.keys(props).filter(k => !blocked.has(k));
-          }
+        has(property) {
+          return k.includes(property) && property in props;
         },
-        propTraps
-      )
-    );
+        keys() {
+          return k.filter(property => property in props);
+        }
+      }, propTraps);
+    });
+    res.push(new Proxy({
+      get(property) {
+        return blocked.has(property) ? undefined : props[property];
+      },
+      has(property) {
+        return blocked.has(property) ? false : property in props;
+      },
+      keys() {
+        return Object.keys(props).filter(k => !blocked.has(k));
+      }
+    }, propTraps));
     return res;
   }
   const otherObject = {};
   const objects = keys.map(() => ({}));
   for (const propName of Object.getOwnPropertyNames(props)) {
     const desc = Object.getOwnPropertyDescriptor(props, propName);
-    const isDefaultDesc =
-      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
+    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
     let blocked = false;
     let objectIndex = 0;
     for (const k of keys) {
       if (k.includes(propName)) {
         blocked = true;
-        isDefaultDesc
-          ? (objects[objectIndex][propName] = desc.value)
-          : Object.defineProperty(objects[objectIndex], propName, desc);
+        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
       }
       ++objectIndex;
     }
     if (!blocked) {
-      isDefaultDesc
-        ? (otherObject[propName] = desc.value)
-        : Object.defineProperty(otherObject, propName, desc);
+      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
     }
   }
   return [...objects, otherObject];
@@ -1528,21 +1412,17 @@ function lazy(fn) {
       comp = s;
     }
     let Comp;
-    return createMemo(() =>
-      (Comp = comp())
-        ? untrack(() => {
-            if (false);
-            if (!ctx || sharedConfig.done) return Comp(props);
-            const c = sharedConfig.context;
-            setHydrateContext(ctx);
-            const r = Comp(props);
-            setHydrateContext(c);
-            return r;
-          })
-        : ""
-    );
+    return createMemo(() => (Comp = comp()) ? untrack(() => {
+      if (false) ;
+      if (!ctx || sharedConfig.done) return Comp(props);
+      const c = sharedConfig.context;
+      setHydrateContext(ctx);
+      const r = Comp(props);
+      setHydrateContext(c);
+      return r;
+    }) : "");
   };
-  wrap.preload = () => p || ((p = fn()).then(mod => (comp = () => mod.default)), p);
+  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);
   return wrap;
 }
 let counter = 0;
@@ -1567,77 +1447,49 @@ function Index(props) {
 function Show(props) {
   const keyed = props.keyed;
   const condition = createMemo(() => props.when, undefined, {
-    equals: (a, b) => (keyed ? a === b : !a === !b)
+    equals: (a, b) => keyed ? a === b : !a === !b
   });
-  return createMemo(
-    () => {
-      const c = condition();
-      if (c) {
-        const child = props.children;
-        const fn = typeof child === "function" && child.length > 0;
-        return fn
-          ? untrack(() =>
-              child(
-                keyed
-                  ? c
-                  : () => {
-                      if (!untrack(condition)) throw narrowedError("Show");
-                      return props.when;
-                    }
-              )
-            )
-          : child;
-      }
-      return props.fallback;
-    },
-    undefined,
-    undefined
-  );
+  return createMemo(() => {
+    const c = condition();
+    if (c) {
+      const child = props.children;
+      const fn = typeof child === "function" && child.length > 0;
+      return fn ? untrack(() => child(keyed ? c : () => {
+        if (!untrack(condition)) throw narrowedError("Show");
+        return props.when;
+      })) : child;
+    }
+    return props.fallback;
+  }, undefined, undefined);
 }
 function Switch(props) {
   let keyed = false;
   const equals = (a, b) => (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];
   const conditions = children(() => props.children),
-    evalConditions = createMemo(
-      () => {
-        let conds = conditions();
-        if (!Array.isArray(conds)) conds = [conds];
-        for (let i = 0; i < conds.length; i++) {
-          const c = conds[i].when;
-          if (c) {
-            keyed = !!conds[i].keyed;
-            return [i, c, conds[i]];
-          }
+    evalConditions = createMemo(() => {
+      let conds = conditions();
+      if (!Array.isArray(conds)) conds = [conds];
+      for (let i = 0; i < conds.length; i++) {
+        const c = conds[i].when;
+        if (c) {
+          keyed = !!conds[i].keyed;
+          return [i, c, conds[i]];
         }
-        return [-1];
-      },
-      undefined,
-      {
-        equals
       }
-    );
-  return createMemo(
-    () => {
-      const [index, when, cond] = evalConditions();
-      if (index < 0) return props.fallback;
-      const c = cond.children;
-      const fn = typeof c === "function" && c.length > 0;
-      return fn
-        ? untrack(() =>
-            c(
-              keyed
-                ? when
-                : () => {
-                    if (untrack(evalConditions)[0] !== index) throw narrowedError("Match");
-                    return cond.when;
-                  }
-            )
-          )
-        : c;
-    },
-    undefined,
-    undefined
-  );
+      return [-1];
+    }, undefined, {
+      equals
+    });
+  return createMemo(() => {
+    const [index, when, cond] = evalConditions();
+    if (index < 0) return props.fallback;
+    const c = cond.children;
+    const fn = typeof c === "function" && c.length > 0;
+    return fn ? untrack(() => c(keyed ? when : () => {
+      if (untrack(evalConditions)[0] !== index) throw narrowedError("Match");
+      return cond.when;
+    })) : c;
+  }, undefined, undefined);
 }
 function Match(props) {
   return props;
@@ -1648,29 +1500,23 @@ function resetErrorBoundaries() {
 }
 function ErrorBoundary(props) {
   let err;
-  if (sharedConfig.context && sharedConfig.load)
-    err = sharedConfig.load(sharedConfig.getContextId());
+  if (sharedConfig.context && sharedConfig.load) err = sharedConfig.load(sharedConfig.getContextId());
   const [errored, setErrored] = createSignal(err, undefined);
   Errors || (Errors = new Set());
   Errors.add(setErrored);
   onCleanup(() => Errors.delete(setErrored));
-  return createMemo(
-    () => {
-      let e;
-      if ((e = errored())) {
-        const f = props.fallback;
-        return typeof f === "function" && f.length ? untrack(() => f(e, () => setErrored())) : f;
-      }
-      return catchError(() => props.children, setErrored);
-    },
-    undefined,
-    undefined
-  );
+  return createMemo(() => {
+    let e;
+    if (e = errored()) {
+      const f = props.fallback;
+      return typeof f === "function" && f.length ? untrack(() => f(e, () => setErrored())) : f;
+    }
+    return catchError(() => props.children, setErrored);
+  }, undefined, undefined);
 }
 
-const suspenseListEquals = (a, b) =>
-  a.showContent === b.showContent && a.showFallback === b.showFallback;
-const SuspenseListContext = /* #__PURE__ */ createContext();
+const suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;
+const SuspenseListContext = /* #__PURE__ */createContext();
 function SuspenseList(props) {
   let [wrapper, setWrapper] = createSignal(() => ({
       inFallback: false
@@ -1681,51 +1527,51 @@ function SuspenseList(props) {
   if (listContext) {
     show = listContext.register(createMemo(() => wrapper()().inFallback));
   }
-  const resolved = createMemo(
-    prev => {
-      const reveal = props.revealOrder,
-        tail = props.tail,
-        { showContent = true, showFallback = true } = show ? show() : {},
-        reg = registry(),
-        reverse = reveal === "backwards";
-      if (reveal === "together") {
-        const all = reg.every(inFallback => !inFallback());
-        const res = reg.map(() => ({
-          showContent: all && showContent,
+  const resolved = createMemo(prev => {
+    const reveal = props.revealOrder,
+      tail = props.tail,
+      {
+        showContent = true,
+        showFallback = true
+      } = show ? show() : {},
+      reg = registry(),
+      reverse = reveal === "backwards";
+    if (reveal === "together") {
+      const all = reg.every(inFallback => !inFallback());
+      const res = reg.map(() => ({
+        showContent: all && showContent,
+        showFallback
+      }));
+      res.inFallback = !all;
+      return res;
+    }
+    let stop = false;
+    let inFallback = prev.inFallback;
+    const res = [];
+    for (let i = 0, len = reg.length; i < len; i++) {
+      const n = reverse ? len - i - 1 : i,
+        s = reg[n]();
+      if (!stop && !s) {
+        res[n] = {
+          showContent,
           showFallback
-        }));
-        res.inFallback = !all;
-        return res;
-      }
-      let stop = false;
-      let inFallback = prev.inFallback;
-      const res = [];
-      for (let i = 0, len = reg.length; i < len; i++) {
-        const n = reverse ? len - i - 1 : i,
-          s = reg[n]();
-        if (!stop && !s) {
-          res[n] = {
-            showContent,
-            showFallback
-          };
-        } else {
-          const next = !stop;
-          if (next) inFallback = true;
-          res[n] = {
-            showContent: next,
-            showFallback: !tail || (next && tail === "collapsed") ? showFallback : false
-          };
-          stop = true;
-        }
+        };
+      } else {
+        const next = !stop;
+        if (next) inFallback = true;
+        res[n] = {
+          showContent: next,
+          showFallback: !tail || next && tail === "collapsed" ? showFallback : false
+        };
+        stop = true;
       }
-      if (!stop) inFallback = false;
-      res.inFallback = inFallback;
-      return res;
-    },
-    {
-      inFallback: false
     }
-  );
+    if (!stop) inFallback = false;
+    res.inFallback = inFallback;
+    return res;
+  }, {
+    inFallback: false
+  });
   setWrapper(() => resolved);
   return createComponent(SuspenseListContext.Provider, {
     value: {
@@ -1770,27 +1616,23 @@ function Suspense(props) {
     const key = sharedConfig.getContextId();
     let ref = sharedConfig.load(key);
     if (ref) {
-      if (typeof ref !== "object" || ref.status !== "success") p = ref;
-      else sharedConfig.gather(key);
+      if (typeof ref !== "object" || ref.status !== "success") p = ref;else sharedConfig.gather(key);
     }
     if (p && p !== "$$f") {
       const [s, set] = createSignal(undefined, {
         equals: false
       });
       flicker = s;
-      p.then(
-        () => {
-          if (sharedConfig.done) return set();
-          sharedConfig.gather(key);
-          setHydrateContext(ctx);
-          set();
-          setHydrateContext();
-        },
-        err => {
-          error = err;
-          set();
-        }
-      );
+      p.then(() => {
+        if (sharedConfig.done) return set();
+        sharedConfig.gather(key);
+        setHydrateContext(ctx);
+        set();
+        setHydrateContext();
+      }, err => {
+        error = err;
+        set();
+      });
     }
   }
   const listContext = useContext(SuspenseListContext);
@@ -1805,14 +1647,17 @@ function Suspense(props) {
         ctx = sharedConfig.context;
         if (flicker) {
           flicker();
-          return (flicker = undefined);
+          return flicker = undefined;
         }
         if (ctx && p === "$$f") setHydrateContext();
         const rendered = createMemo(() => props.children);
         return createMemo(prev => {
           const inFallback = store.inFallback(),
-            { showContent = true, showFallback = true } = show ? show() : {};
-          if ((!inFallback || (p && p !== "$$f")) && showContent) {
+            {
+              showContent = true,
+              showFallback = true
+            } = show ? show() : {};
+          if ((!inFallback || p && p !== "$$f") && showContent) {
             store.resolved = true;
             dispose && dispose();
             dispose = ctx = p = undefined;
@@ -1840,59 +1685,4 @@ function Suspense(props) {
 
 const DEV = undefined;
 
-export {
-  $DEVCOMP,
-  $PROXY,
-  $TRACK,
-  DEV,
-  ErrorBoundary,
-  For,
-  Index,
-  Match,
-  Show,
-  Suspense,
-  SuspenseList,
-  Switch,
-  batch,
-  cancelCallback,
-  catchError,
-  children,
-  createComponent,
-  createComputed,
-  createContext,
-  createDeferred,
-  createEffect,
-  createMemo,
-  createReaction,
-  createRenderEffect,
-  createResource,
-  createRoot,
-  createSelector,
-  createSignal,
-  createUniqueId,
-  enableExternalSource,
-  enableHydration,
-  enableScheduling,
-  equalFn,
-  from,
-  getListener,
-  getOwner,
-  indexArray,
-  lazy,
-  mapArray,
-  mergeProps,
-  observable,
-  on,
-  onCleanup,
-  onError,
-  onMount,
-  requestCallback,
-  resetErrorBoundaries,
-  runWithOwner,
-  sharedConfig,
-  splitProps,
-  startTransition,
-  untrack,
-  useContext,
-  useTransition
-};
+export { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, catchError, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };
diff --git a/store/dist/dev.cjs b/store/dist/dev.cjs
index 3b9a413b2c494e09010a15bd3cb8c7850aafd2a7..57961388696a5ebfc3bc42acc22c3388896e4b35 100644
--- a/store/dist/dev.cjs
+++ b/store/dist/dev.cjs
@@ -341,7 +341,7 @@ function applyState(target, parent, property, merge, key) {
       }
       const temp = new Array(target.length),
         newIndices = new Map();
-      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
+      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
         temp[newEnd] = previous[end];
       }
       if (start > newEnd || start > end) {
@@ -439,10 +439,17 @@ function produce(fn) {
 }
 
 const DEV = {
-  $NODE,
-  isWrappable,
+  $NODE: $NODE,
+  $HAS: $HAS,
+  $RAW: $RAW,
+  $SELF: $SELF,
+  isWrappable: isWrappable,
+  unwrap: unwrap,
   hooks: DevHooks
 } ;
+if (globalThis) {
+  globalThis.SolidStore$$ = DEV;
+}
 
 exports.$RAW = $RAW;
 exports.DEV = DEV;
diff --git a/store/dist/dev.js b/store/dist/dev.js
index 8d52c37224b2d4849ea86fdbeb6db874f9fb6d81..618d0aa6e79aba08aabe26f94ed16f4a969ae13a 100644
--- a/store/dist/dev.js
+++ b/store/dist/dev.js
@@ -1,4 +1,4 @@
-import { DEV as DEV$1, $PROXY, $TRACK, getListener, batch, createSignal } from "solid-js";
+import { DEV as DEV$1, $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';
 
 const $RAW = Symbol("store-raw"),
   $NODE = Symbol("store-node"),
@@ -11,7 +11,7 @@ function wrap$1(value) {
   let p = value[$PROXY];
   if (!p) {
     Object.defineProperty(value, $PROXY, {
-      value: (p = new Proxy(value, proxyTraps$1))
+      value: p = new Proxy(value, proxyTraps$1)
     });
     if (!Array.isArray(value)) {
       const keys = Object.keys(value),
@@ -31,29 +31,20 @@ function wrap$1(value) {
 }
 function isWrappable(obj) {
   let proto;
-  return (
-    obj != null &&
-    typeof obj === "object" &&
-    (obj[$PROXY] ||
-      !(proto = Object.getPrototypeOf(obj)) ||
-      proto === Object.prototype ||
-      Array.isArray(obj))
-  );
+  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
 }
 function unwrap(item, set = new Set()) {
   let result, unwrapped, v, prop;
-  if ((result = item != null && item[$RAW])) return result;
+  if (result = item != null && item[$RAW]) return result;
   if (!isWrappable(item) || set.has(item)) return item;
   if (Array.isArray(item)) {
-    if (Object.isFrozen(item)) item = item.slice(0);
-    else set.add(item);
+    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);
     for (let i = 0, l = item.length; i < l; i++) {
       v = item[i];
       if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
     }
   } else {
-    if (Object.isFrozen(item)) item = Object.assign({}, item);
-    else set.add(item);
+    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);
     const keys = Object.keys(item),
       desc = Object.getOwnPropertyDescriptors(item);
     for (let i = 0, l = keys.length; i < l; i++) {
@@ -67,10 +58,9 @@ function unwrap(item, set = new Set()) {
 }
 function getNodes(target, symbol) {
   let nodes = target[symbol];
-  if (!nodes)
-    Object.defineProperty(target, symbol, {
-      value: (nodes = Object.create(null))
-    });
+  if (!nodes) Object.defineProperty(target, symbol, {
+    value: nodes = Object.create(null)
+  });
   return nodes;
 }
 function getNode(nodes, property, value) {
@@ -80,12 +70,11 @@ function getNode(nodes, property, value) {
     internal: true
   });
   s.$ = set;
-  return (nodes[property] = s);
+  return nodes[property] = s;
 }
 function proxyDescriptor$1(target, property) {
   const desc = Reflect.getOwnPropertyDescriptor(target, property);
-  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)
-    return desc;
+  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;
   delete desc.value;
   delete desc.writable;
   desc.get = () => target[$PROXY][property];
@@ -112,25 +101,12 @@ const proxyTraps$1 = {
     if (property === $NODE || property === $HAS || property === "__proto__") return value;
     if (!tracked) {
       const desc = Object.getOwnPropertyDescriptor(target, property);
-      if (
-        getListener() &&
-        (typeof value !== "function" || target.hasOwnProperty(property)) &&
-        !(desc && desc.get)
-      )
-        value = getNode(nodes, property, value)();
+      if (getListener() && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();
     }
     return isWrappable(value) ? wrap$1(value) : value;
   },
   has(target, property) {
-    if (
-      property === $RAW ||
-      property === $PROXY ||
-      property === $TRACK ||
-      property === $NODE ||
-      property === $HAS ||
-      property === "__proto__"
-    )
-      return true;
+    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__") return true;
     getListener() && getNode(getNodes(target, $HAS), property)();
     return property in target;
   },
@@ -159,7 +135,7 @@ function setProperty(state, property, value, deleting = false) {
   }
   let nodes = getNodes(state, $NODE),
     node;
-  if ((node = getNode(nodes, property, prev))) node.$(() => value);
+  if (node = getNode(nodes, property, prev)) node.$(() => value);
   if (Array.isArray(state) && state.length !== len) {
     for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();
     (node = getNode(nodes, "length", len)) && node.$(state.length);
@@ -205,7 +181,11 @@ function updatePath(current, path, traversed = []) {
       }
       return;
     } else if (isArray && partType === "object") {
-      const { from = 0, to = current.length - 1, by = 1 } = part;
+      const {
+        from = 0,
+        to = current.length - 1,
+        by = 1
+      } = part;
       for (let i = from; i <= to; i += by) {
         updatePath(current, [i].concat(path), traversed);
       }
@@ -224,17 +204,14 @@ function updatePath(current, path, traversed = []) {
   }
   if (part === undefined && value == undefined) return;
   value = unwrap(value);
-  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {
+  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {
     mergeStoreNode(prev, value);
   } else setProperty(current, part, value);
 }
 function createStore(...[store, options]) {
   const unwrappedStore = unwrap(store || {});
   const isArray = Array.isArray(unwrappedStore);
-  if (typeof unwrappedStore !== "object" && typeof unwrappedStore !== "function")
-    throw new Error(
-      `Unexpected type ${typeof unwrappedStore} received when initializing 'createStore'. Expected an object.`
-    );
+  if (typeof unwrappedStore !== "object" && typeof unwrappedStore !== "function") throw new Error(`Unexpected type ${typeof unwrappedStore} received when initializing 'createStore'. Expected an object.`);
   const wrappedStore = wrap$1(unwrappedStore);
   DEV$1.registerGraph({
     value: unwrappedStore,
@@ -242,9 +219,7 @@ function createStore(...[store, options]) {
   });
   function setStore(...args) {
     batch(() => {
-      isArray && args.length === 1
-        ? updateArray(unwrappedStore, args[0])
-        : updatePath(unwrappedStore, args);
+      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
     });
   }
   return [wrappedStore, setStore];
@@ -252,19 +227,11 @@ function createStore(...[store, options]) {
 
 function proxyDescriptor(target, property) {
   const desc = Reflect.getOwnPropertyDescriptor(target, property);
-  if (
-    !desc ||
-    desc.get ||
-    desc.set ||
-    !desc.configurable ||
-    property === $PROXY ||
-    property === $NODE
-  )
-    return desc;
+  if (!desc || desc.get || desc.set || !desc.configurable || property === $PROXY || property === $NODE) return desc;
   delete desc.value;
   delete desc.writable;
   desc.get = () => target[$PROXY][property];
-  desc.set = v => (target[$PROXY][property] = v);
+  desc.set = v => target[$PROXY][property] = v;
   return desc;
 }
 const proxyTraps = {
@@ -282,24 +249,14 @@ const proxyTraps = {
     if (!tracked) {
       const desc = Object.getOwnPropertyDescriptor(target, property);
       const isFunction = typeof value === "function";
-      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))
-        value = getNode(nodes, property, value)();
-      else if (value != null && isFunction && value === Array.prototype[property]) {
+      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {
         return (...args) => batch(() => Array.prototype[property].apply(receiver, args));
       }
     }
     return isWrappable(value) ? wrap(value) : value;
   },
   has(target, property) {
-    if (
-      property === $RAW ||
-      property === $PROXY ||
-      property === $TRACK ||
-      property === $NODE ||
-      property === $HAS ||
-      property === "__proto__"
-    )
-      return true;
+    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__") return true;
     getListener() && getNode(getNodes(target, $HAS), property)();
     return property in target;
   },
@@ -318,17 +275,12 @@ function wrap(value) {
   let p = value[$PROXY];
   if (!p) {
     Object.defineProperty(value, $PROXY, {
-      value: (p = new Proxy(value, proxyTraps))
+      value: p = new Proxy(value, proxyTraps)
     });
     const keys = Object.keys(value),
       desc = Object.getOwnPropertyDescriptors(value);
     const proto = Object.getPrototypeOf(value);
-    const isClass =
-      proto !== null &&
-      value !== null &&
-      typeof value === "object" &&
-      !Array.isArray(value) &&
-      proto !== Object.prototype;
+    const isClass = proto !== null && value !== null && typeof value === "object" && !Array.isArray(value) && proto !== Object.prototype;
     if (isClass) {
       const descriptors = Object.getOwnPropertyDescriptors(proto);
       keys.push(...Object.keys(descriptors));
@@ -358,10 +310,7 @@ function wrap(value) {
 }
 function createMutable(state, options) {
   const unwrappedStore = unwrap(state || {});
-  if (typeof unwrappedStore !== "object" && typeof unwrappedStore !== "function")
-    throw new Error(
-      `Unexpected type ${typeof unwrappedStore} received when initializing 'createMutable'. Expected an object.`
-    );
+  if (typeof unwrappedStore !== "object" && typeof unwrappedStore !== "function") throw new Error(`Unexpected type ${typeof unwrappedStore} received when initializing 'createMutable'. Expected an object.`);
   const wrappedStore = wrap(unwrappedStore);
   DEV$1.registerGraph({
     value: unwrappedStore,
@@ -378,42 +327,19 @@ function applyState(target, parent, property, merge, key) {
   const previous = parent[property];
   if (target === previous) return;
   const isArray = Array.isArray(target);
-  if (
-    property !== $ROOT &&
-    (!isWrappable(target) ||
-      !isWrappable(previous) ||
-      isArray !== Array.isArray(previous) ||
-      (key && target[key] !== previous[key]))
-  ) {
+  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray !== Array.isArray(previous) || key && target[key] !== previous[key])) {
     setProperty(parent, property, target);
     return;
   }
   if (isArray) {
-    if (
-      target.length &&
-      previous.length &&
-      (!merge || (key && target[0] && target[0][key] != null))
-    ) {
+    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {
       let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
-      for (
-        start = 0, end = Math.min(previous.length, target.length);
-        start < end &&
-        (previous[start] === target[start] ||
-          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));
-        start++
-      ) {
+      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {
         applyState(target[start], previous, start, merge, key);
       }
       const temp = new Array(target.length),
         newIndices = new Map();
-      for (
-        end = previous.length - 1, newEnd = target.length - 1;
-        end >= start &&
-        newEnd >= start &&
-        (previous[end] === target[newEnd] ||
-          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));
-        end--, newEnd--
-      ) {
+      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
         temp[newEnd] = previous[end];
       }
       if (start > newEnd || start > end) {
@@ -467,19 +393,16 @@ function applyState(target, parent, property, merge, key) {
   }
 }
 function reconcile(value, options = {}) {
-  const { merge, key = "id" } = options,
+  const {
+      merge,
+      key = "id"
+    } = options,
     v = unwrap(value);
   return state => {
     if (!isWrappable(state) || !isWrappable(v)) return v;
-    const res = applyState(
-      v,
-      {
-        [$ROOT]: state
-      },
-      $ROOT,
-      merge,
-      key
-    );
+    const res = applyState(v, {
+      [$ROOT]: state
+    }, $ROOT, merge, key);
     return res === undefined ? state : res;
   };
 }
@@ -489,10 +412,7 @@ const setterTraps = {
     if (property === $RAW) return target;
     const value = target[property];
     let proxy;
-    return isWrappable(value)
-      ? producers.get(value) ||
-          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)
-      : value;
+    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;
   },
   set(target, property, value) {
     setProperty(target, property, unwrap(value));
@@ -508,7 +428,7 @@ function produce(fn) {
     if (isWrappable(state)) {
       let proxy;
       if (!(proxy = producers.get(state))) {
-        producers.set(state, (proxy = new Proxy(state, setterTraps)));
+        producers.set(state, proxy = new Proxy(state, setterTraps));
       }
       fn(proxy);
     }
@@ -517,9 +437,16 @@ function produce(fn) {
 }
 
 const DEV = {
-  $NODE,
-  isWrappable,
+  $NODE: $NODE,
+  $HAS: $HAS,
+  $RAW: $RAW,
+  $SELF: $SELF,
+  isWrappable: isWrappable,
+  unwrap: unwrap,
   hooks: DevHooks
-};
+} ;
+if (globalThis) {
+  globalThis.SolidStore$$ = DEV;
+}
 
 export { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };
diff --git a/store/dist/server.js b/store/dist/server.js
index a9ecdf897ee3c3f3204a44fa4a9e9587c19fa10c..fbd9254e9f26e3286f869f16db2d7c29d00874e5 100644
--- a/store/dist/server.js
+++ b/store/dist/server.js
@@ -1,10 +1,6 @@
 const $RAW = Symbol("state-raw");
 function isWrappable(obj) {
-  return (
-    obj != null &&
-    typeof obj === "object" &&
-    (Object.getPrototypeOf(obj) === Object.prototype || Array.isArray(obj))
-  );
+  return obj != null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Array.isArray(obj));
 }
 function unwrap(item) {
   return item;
@@ -53,7 +49,11 @@ function updatePath(current, path, traversed = []) {
       }
       return;
     } else if (isArray && partType === "object") {
-      const { from = 0, to = current.length - 1, by = 1 } = part;
+      const {
+        from = 0,
+        to = current.length - 1,
+        by = 1
+      } = part;
       for (let i = from; i <= to; i += by) {
         updatePath(current, [i].concat(path), traversed);
       }
@@ -71,7 +71,7 @@ function updatePath(current, path, traversed = []) {
     if (value === next) return;
   }
   if (part === undefined && value == undefined) return;
-  if (part === undefined || (isWrappable(next) && isWrappable(value) && !Array.isArray(value))) {
+  if (part === undefined || isWrappable(next) && isWrappable(value) && !Array.isArray(value)) {
     mergeStoreNode(next, value);
   } else setProperty(current, part, value);
 }
@@ -111,16 +111,4 @@ function produce(fn) {
 }
 const DEV = undefined;
 
-export {
-  $RAW,
-  DEV,
-  createMutable,
-  createStore,
-  isWrappable,
-  modifyMutable,
-  produce,
-  reconcile,
-  setProperty,
-  unwrap,
-  updatePath
-};
+export { $RAW, DEV, createMutable, createStore, isWrappable, modifyMutable, produce, reconcile, setProperty, unwrap, updatePath };
diff --git a/store/dist/store.cjs b/store/dist/store.cjs
index e1a27af53ed58bd6381dd5fc9eb35363c0ed5d10..7803b704245e299faf209a23ee5af72b1a40fdb0 100644
--- a/store/dist/store.cjs
+++ b/store/dist/store.cjs
@@ -325,7 +325,7 @@ function applyState(target, parent, property, merge, key) {
       }
       const temp = new Array(target.length),
         newIndices = new Map();
-      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
+      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
         temp[newEnd] = previous[end];
       }
       if (start > newEnd || start > end) {
diff --git a/store/dist/store.js b/store/dist/store.js
index fb518424106d2b1238933e9a1a5f94b7a72a6232..5972e440e5ae2ce986240dbbdafebd44c7d1c146 100644
--- a/store/dist/store.js
+++ b/store/dist/store.js
@@ -1,4 +1,4 @@
-import { $PROXY, $TRACK, getListener, batch, createSignal } from "solid-js";
+import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';
 
 const $RAW = Symbol("store-raw"),
   $NODE = Symbol("store-node"),
@@ -8,7 +8,7 @@ function wrap$1(value) {
   let p = value[$PROXY];
   if (!p) {
     Object.defineProperty(value, $PROXY, {
-      value: (p = new Proxy(value, proxyTraps$1))
+      value: p = new Proxy(value, proxyTraps$1)
     });
     if (!Array.isArray(value)) {
       const keys = Object.keys(value),
@@ -28,29 +28,20 @@ function wrap$1(value) {
 }
 function isWrappable(obj) {
   let proto;
-  return (
-    obj != null &&
-    typeof obj === "object" &&
-    (obj[$PROXY] ||
-      !(proto = Object.getPrototypeOf(obj)) ||
-      proto === Object.prototype ||
-      Array.isArray(obj))
-  );
+  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
 }
 function unwrap(item, set = new Set()) {
   let result, unwrapped, v, prop;
-  if ((result = item != null && item[$RAW])) return result;
+  if (result = item != null && item[$RAW]) return result;
   if (!isWrappable(item) || set.has(item)) return item;
   if (Array.isArray(item)) {
-    if (Object.isFrozen(item)) item = item.slice(0);
-    else set.add(item);
+    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);
     for (let i = 0, l = item.length; i < l; i++) {
       v = item[i];
       if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
     }
   } else {
-    if (Object.isFrozen(item)) item = Object.assign({}, item);
-    else set.add(item);
+    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);
     const keys = Object.keys(item),
       desc = Object.getOwnPropertyDescriptors(item);
     for (let i = 0, l = keys.length; i < l; i++) {
@@ -64,10 +55,9 @@ function unwrap(item, set = new Set()) {
 }
 function getNodes(target, symbol) {
   let nodes = target[symbol];
-  if (!nodes)
-    Object.defineProperty(target, symbol, {
-      value: (nodes = Object.create(null))
-    });
+  if (!nodes) Object.defineProperty(target, symbol, {
+    value: nodes = Object.create(null)
+  });
   return nodes;
 }
 function getNode(nodes, property, value) {
@@ -77,12 +67,11 @@ function getNode(nodes, property, value) {
     internal: true
   });
   s.$ = set;
-  return (nodes[property] = s);
+  return nodes[property] = s;
 }
 function proxyDescriptor$1(target, property) {
   const desc = Reflect.getOwnPropertyDescriptor(target, property);
-  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)
-    return desc;
+  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;
   delete desc.value;
   delete desc.writable;
   desc.get = () => target[$PROXY][property];
@@ -109,25 +98,12 @@ const proxyTraps$1 = {
     if (property === $NODE || property === $HAS || property === "__proto__") return value;
     if (!tracked) {
       const desc = Object.getOwnPropertyDescriptor(target, property);
-      if (
-        getListener() &&
-        (typeof value !== "function" || target.hasOwnProperty(property)) &&
-        !(desc && desc.get)
-      )
-        value = getNode(nodes, property, value)();
+      if (getListener() && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();
     }
     return isWrappable(value) ? wrap$1(value) : value;
   },
   has(target, property) {
-    if (
-      property === $RAW ||
-      property === $PROXY ||
-      property === $TRACK ||
-      property === $NODE ||
-      property === $HAS ||
-      property === "__proto__"
-    )
-      return true;
+    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__") return true;
     getListener() && getNode(getNodes(target, $HAS), property)();
     return property in target;
   },
@@ -153,7 +129,7 @@ function setProperty(state, property, value, deleting = false) {
   }
   let nodes = getNodes(state, $NODE),
     node;
-  if ((node = getNode(nodes, property, prev))) node.$(() => value);
+  if (node = getNode(nodes, property, prev)) node.$(() => value);
   if (Array.isArray(state) && state.length !== len) {
     for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();
     (node = getNode(nodes, "length", len)) && node.$(state.length);
@@ -199,7 +175,11 @@ function updatePath(current, path, traversed = []) {
       }
       return;
     } else if (isArray && partType === "object") {
-      const { from = 0, to = current.length - 1, by = 1 } = part;
+      const {
+        from = 0,
+        to = current.length - 1,
+        by = 1
+      } = part;
       for (let i = from; i <= to; i += by) {
         updatePath(current, [i].concat(path), traversed);
       }
@@ -218,7 +198,7 @@ function updatePath(current, path, traversed = []) {
   }
   if (part === undefined && value == undefined) return;
   value = unwrap(value);
-  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {
+  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {
     mergeStoreNode(prev, value);
   } else setProperty(current, part, value);
 }
@@ -228,9 +208,7 @@ function createStore(...[store, options]) {
   const wrappedStore = wrap$1(unwrappedStore);
   function setStore(...args) {
     batch(() => {
-      isArray && args.length === 1
-        ? updateArray(unwrappedStore, args[0])
-        : updatePath(unwrappedStore, args);
+      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
     });
   }
   return [wrappedStore, setStore];
@@ -238,19 +216,11 @@ function createStore(...[store, options]) {
 
 function proxyDescriptor(target, property) {
   const desc = Reflect.getOwnPropertyDescriptor(target, property);
-  if (
-    !desc ||
-    desc.get ||
-    desc.set ||
-    !desc.configurable ||
-    property === $PROXY ||
-    property === $NODE
-  )
-    return desc;
+  if (!desc || desc.get || desc.set || !desc.configurable || property === $PROXY || property === $NODE) return desc;
   delete desc.value;
   delete desc.writable;
   desc.get = () => target[$PROXY][property];
-  desc.set = v => (target[$PROXY][property] = v);
+  desc.set = v => target[$PROXY][property] = v;
   return desc;
 }
 const proxyTraps = {
@@ -268,24 +238,14 @@ const proxyTraps = {
     if (!tracked) {
       const desc = Object.getOwnPropertyDescriptor(target, property);
       const isFunction = typeof value === "function";
-      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))
-        value = getNode(nodes, property, value)();
-      else if (value != null && isFunction && value === Array.prototype[property]) {
+      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {
         return (...args) => batch(() => Array.prototype[property].apply(receiver, args));
       }
     }
     return isWrappable(value) ? wrap(value) : value;
   },
   has(target, property) {
-    if (
-      property === $RAW ||
-      property === $PROXY ||
-      property === $TRACK ||
-      property === $NODE ||
-      property === $HAS ||
-      property === "__proto__"
-    )
-      return true;
+    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__") return true;
     getListener() && getNode(getNodes(target, $HAS), property)();
     return property in target;
   },
@@ -304,17 +264,12 @@ function wrap(value) {
   let p = value[$PROXY];
   if (!p) {
     Object.defineProperty(value, $PROXY, {
-      value: (p = new Proxy(value, proxyTraps))
+      value: p = new Proxy(value, proxyTraps)
     });
     const keys = Object.keys(value),
       desc = Object.getOwnPropertyDescriptors(value);
     const proto = Object.getPrototypeOf(value);
-    const isClass =
-      proto !== null &&
-      value !== null &&
-      typeof value === "object" &&
-      !Array.isArray(value) &&
-      proto !== Object.prototype;
+    const isClass = proto !== null && value !== null && typeof value === "object" && !Array.isArray(value) && proto !== Object.prototype;
     if (isClass) {
       const descriptors = Object.getOwnPropertyDescriptors(proto);
       keys.push(...Object.keys(descriptors));
@@ -356,42 +311,19 @@ function applyState(target, parent, property, merge, key) {
   const previous = parent[property];
   if (target === previous) return;
   const isArray = Array.isArray(target);
-  if (
-    property !== $ROOT &&
-    (!isWrappable(target) ||
-      !isWrappable(previous) ||
-      isArray !== Array.isArray(previous) ||
-      (key && target[key] !== previous[key]))
-  ) {
+  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray !== Array.isArray(previous) || key && target[key] !== previous[key])) {
     setProperty(parent, property, target);
     return;
   }
   if (isArray) {
-    if (
-      target.length &&
-      previous.length &&
-      (!merge || (key && target[0] && target[0][key] != null))
-    ) {
+    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {
       let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
-      for (
-        start = 0, end = Math.min(previous.length, target.length);
-        start < end &&
-        (previous[start] === target[start] ||
-          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));
-        start++
-      ) {
+      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {
         applyState(target[start], previous, start, merge, key);
       }
       const temp = new Array(target.length),
         newIndices = new Map();
-      for (
-        end = previous.length - 1, newEnd = target.length - 1;
-        end >= start &&
-        newEnd >= start &&
-        (previous[end] === target[newEnd] ||
-          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));
-        end--, newEnd--
-      ) {
+      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
         temp[newEnd] = previous[end];
       }
       if (start > newEnd || start > end) {
@@ -445,19 +377,16 @@ function applyState(target, parent, property, merge, key) {
   }
 }
 function reconcile(value, options = {}) {
-  const { merge, key = "id" } = options,
+  const {
+      merge,
+      key = "id"
+    } = options,
     v = unwrap(value);
   return state => {
     if (!isWrappable(state) || !isWrappable(v)) return v;
-    const res = applyState(
-      v,
-      {
-        [$ROOT]: state
-      },
-      $ROOT,
-      merge,
-      key
-    );
+    const res = applyState(v, {
+      [$ROOT]: state
+    }, $ROOT, merge, key);
     return res === undefined ? state : res;
   };
 }
@@ -467,10 +396,7 @@ const setterTraps = {
     if (property === $RAW) return target;
     const value = target[property];
     let proxy;
-    return isWrappable(value)
-      ? producers.get(value) ||
-          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)
-      : value;
+    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;
   },
   set(target, property, value) {
     setProperty(target, property, unwrap(value));
@@ -486,7 +412,7 @@ function produce(fn) {
     if (isWrappable(state)) {
       let proxy;
       if (!(proxy = producers.get(state))) {
-        producers.set(state, (proxy = new Proxy(state, setterTraps)));
+        producers.set(state, proxy = new Proxy(state, setterTraps));
       }
       fn(proxy);
     }
diff --git a/store/types/index.d.ts b/store/types/index.d.ts
index 6c35008285ccd649cc222f72f8801d263281544e..689ddb48911a14ccbf672606be00960b0d93a56a 100644
--- a/store/types/index.d.ts
+++ b/store/types/index.d.ts
@@ -1,26 +1,23 @@
 export { $RAW, createStore, unwrap } from "./store.js";
-export type {
-  ArrayFilterFn,
-  DeepMutable,
-  DeepReadonly,
-  NotWrappable,
-  Part,
-  SetStoreFunction,
-  SolidStore,
-  Store,
-  StoreNode,
-  StorePathRange,
-  StoreSetter
-} from "./store.js";
+export type { ArrayFilterFn, DeepMutable, DeepReadonly, NotWrappable, Part, SetStoreFunction, SolidStore, Store, StoreNode, StorePathRange, StoreSetter } from "./store.js";
 export * from "./mutable.js";
 export * from "./modifiers.js";
-import { $NODE, isWrappable } from "./store.js";
-export declare const DEV:
-  | {
-      readonly $NODE: typeof $NODE;
-      readonly isWrappable: typeof isWrappable;
-      readonly hooks: {
-        onStoreNodeUpdate: import("./store.js").OnStoreNodeUpdate | null;
-      };
-    }
-  | undefined;
+import * as store from "./store.js";
+/**
+ * Development-only solid-js/store apis exposed for debugging,
+ * `undefined` in production or on the server.
+ */
+export declare const DEV: {
+    readonly $NODE: typeof store.$NODE;
+    readonly $HAS: typeof store.$HAS;
+    readonly $RAW: typeof store.$RAW;
+    readonly $SELF: typeof store.$SELF;
+    readonly isWrappable: typeof store.isWrappable;
+    readonly unwrap: typeof store.unwrap;
+    readonly hooks: {
+        onStoreNodeUpdate: store.OnStoreNodeUpdate | null;
+    };
+} | undefined;
+declare global {
+    var SolidStore$$: undefined | typeof DEV;
+}
diff --git a/store/types/modifiers.d.ts b/store/types/modifiers.d.ts
index 536b3b6b26fe6f739eaaf26bb5a3a9a35209854b..898d4b5838b47b7a5be0d2f45aa0413ec0eab3ea 100644
--- a/store/types/modifiers.d.ts
+++ b/store/types/modifiers.d.ts
@@ -1,9 +1,6 @@
 export type ReconcileOptions = {
-  key?: string | null;
-  merge?: boolean;
+    key?: string | null;
+    merge?: boolean;
 };
-export declare function reconcile<T extends U, U>(
-  value: T,
-  options?: ReconcileOptions
-): (state: U) => T;
+export declare function reconcile<T extends U, U>(value: T, options?: ReconcileOptions): (state: U) => T;
 export declare function produce<T>(fn: (state: T) => void): (state: T) => T;
diff --git a/store/types/mutable.d.ts b/store/types/mutable.d.ts
index 517874eb25e6f4f8114b8893ee226f9d7552b991..3f7b39b08d1b3209e92e056505890f5570e9af34 100644
--- a/store/types/mutable.d.ts
+++ b/store/types/mutable.d.ts
@@ -1,8 +1,5 @@
 import { StoreNode } from "./store.js";
-export declare function createMutable<T extends StoreNode>(
-  state: T,
-  options?: {
+export declare function createMutable<T extends StoreNode>(state: T, options?: {
     name?: string;
-  }
-): T;
+}): T;
 export declare function modifyMutable<T>(state: T, modifier: (state: T) => T): void;
diff --git a/store/types/server.d.ts b/store/types/server.d.ts
index ba576a6fdffb8dce45bdcd29c6dac57c0a30767c..370a80a95fff1fbc63e5d8d9cbb2053bed34600a 100644
--- a/store/types/server.d.ts
+++ b/store/types/server.d.ts
@@ -1,37 +1,17 @@
 import type { SetStoreFunction, Store } from "./store.js";
-export type {
-  ArrayFilterFn,
-  DeepMutable,
-  DeepReadonly,
-  NotWrappable,
-  Part,
-  SetStoreFunction,
-  SolidStore,
-  Store,
-  StoreNode,
-  StorePathRange,
-  StoreSetter
-} from "./store.js";
+export type { ArrayFilterFn, DeepMutable, DeepReadonly, NotWrappable, Part, SetStoreFunction, SolidStore, Store, StoreNode, StorePathRange, StoreSetter } from "./store.js";
 export declare const $RAW: unique symbol;
 export declare function isWrappable(obj: any): boolean;
 export declare function unwrap<T>(item: T): T;
-export declare function setProperty(
-  state: any,
-  property: PropertyKey,
-  value: any,
-  force?: boolean
-): void;
+export declare function setProperty(state: any, property: PropertyKey, value: any, force?: boolean): void;
 export declare function updatePath(current: any, path: any[], traversed?: PropertyKey[]): void;
 export declare function createStore<T>(state: T | Store<T>): [Store<T>, SetStoreFunction<T>];
 export declare function createMutable<T>(state: T | Store<T>): T;
 export declare function modifyMutable<T>(state: T, modifier: (state: T) => T): void;
 type ReconcileOptions = {
-  key?: string | null;
-  merge?: boolean;
+    key?: string | null;
+    merge?: boolean;
 };
-export declare function reconcile<T extends U, U extends object>(
-  value: T,
-  options?: ReconcileOptions
-): (state: U) => T;
+export declare function reconcile<T extends U, U extends object>(value: T, options?: ReconcileOptions): (state: U) => T;
 export declare function produce<T>(fn: (state: T) => void): (state: T) => T;
 export declare const DEV: undefined;
diff --git a/store/types/store.d.ts b/store/types/store.d.ts
index 3d4d89cfc106438467da82f17a9c738454ad6c87..57024d638a1999b2e424fa95b48e49b16a4ab724 100644
--- a/store/types/store.d.ts
+++ b/store/types/store.d.ts
@@ -1,38 +1,22 @@
-export declare const $RAW: unique symbol,
-  $NODE: unique symbol,
-  $HAS: unique symbol,
-  $SELF: unique symbol;
+export declare const $RAW: unique symbol, $NODE: unique symbol, $HAS: unique symbol, $SELF: unique symbol;
 export declare const DevHooks: {
-  onStoreNodeUpdate: OnStoreNodeUpdate | null;
+    onStoreNodeUpdate: OnStoreNodeUpdate | null;
 };
 type DataNode = {
-  (): any;
-  $(value?: any): void;
+    (): any;
+    $(value?: any): void;
 };
 export type DataNodes = Record<PropertyKey, DataNode | undefined>;
-export type OnStoreNodeUpdate = (
-  state: StoreNode,
-  property: PropertyKey,
-  value: StoreNode | NotWrappable,
-  prev: StoreNode | NotWrappable
-) => void;
+export type OnStoreNodeUpdate = (state: StoreNode, property: PropertyKey, value: StoreNode | NotWrappable, prev: StoreNode | NotWrappable) => void;
 export interface StoreNode {
-  [$NODE]?: DataNodes;
-  [key: PropertyKey]: any;
+    [$NODE]?: DataNodes;
+    [key: PropertyKey]: any;
 }
 export declare namespace SolidStore {
-  interface Unwrappable {}
+    interface Unwrappable {
+    }
 }
-export type NotWrappable =
-  | string
-  | number
-  | bigint
-  | symbol
-  | boolean
-  | Function
-  | null
-  | undefined
-  | SolidStore.Unwrappable[keyof SolidStore.Unwrappable];
+export type NotWrappable = string | number | bigint | symbol | boolean | Function | null | undefined | SolidStore.Unwrappable[keyof SolidStore.Unwrappable];
 export type Store<T> = T;
 export declare function isWrappable<T>(obj: T | NotWrappable): obj is T;
 /**
@@ -49,215 +33,74 @@ export declare function isWrappable<T>(obj: T | NotWrappable): obj is T;
 export declare function unwrap<T>(item: T, set?: Set<unknown>): T;
 export declare function getNodes(target: StoreNode, symbol: typeof $NODE | typeof $HAS): DataNodes;
 export declare function getNode(nodes: DataNodes, property: PropertyKey, value?: any): DataNode;
-export declare function proxyDescriptor(
-  target: StoreNode,
-  property: PropertyKey
-): TypedPropertyDescriptor<any> | undefined;
+export declare function proxyDescriptor(target: StoreNode, property: PropertyKey): TypedPropertyDescriptor<any> | undefined;
 export declare function trackSelf(target: StoreNode): void;
 export declare function ownKeys(target: StoreNode): (string | symbol)[];
-export declare function setProperty(
-  state: StoreNode,
-  property: PropertyKey,
-  value: any,
-  deleting?: boolean
-): void;
-export declare function updatePath(
-  current: StoreNode,
-  path: any[],
-  traversed?: PropertyKey[]
-): void;
+export declare function setProperty(state: StoreNode, property: PropertyKey, value: any, deleting?: boolean): void;
+export declare function updatePath(current: StoreNode, path: any[], traversed?: PropertyKey[]): void;
 /** @deprecated */
-export type DeepReadonly<T> = 0 extends 1 & T
-  ? T
-  : T extends NotWrappable
-  ? T
-  : {
-      readonly [K in keyof T]: DeepReadonly<T[K]>;
-    };
+export type DeepReadonly<T> = 0 extends 1 & T ? T : T extends NotWrappable ? T : {
+    readonly [K in keyof T]: DeepReadonly<T[K]>;
+};
 /** @deprecated */
-export type DeepMutable<T> = 0 extends 1 & T
-  ? T
-  : T extends NotWrappable
-  ? T
-  : {
-      -readonly [K in keyof T]: DeepMutable<T[K]>;
-    };
-export type CustomPartial<T> = T extends readonly unknown[]
-  ? "0" extends keyof T
-    ? {
-        [K in Extract<keyof T, `${number}`>]?: T[K];
-      }
-    : {
-        [x: number]: T[number];
-      }
-  : Partial<T>;
+export type DeepMutable<T> = 0 extends 1 & T ? T : T extends NotWrappable ? T : {
+    -readonly [K in keyof T]: DeepMutable<T[K]>;
+};
+export type CustomPartial<T> = T extends readonly unknown[] ? "0" extends keyof T ? {
+    [K in Extract<keyof T, `${number}`>]?: T[K];
+} : {
+    [x: number]: T[number];
+} : Partial<T>;
 export type PickMutable<T> = {
-  [K in keyof T as (<U>() => U extends {
-    [V in K]: T[V];
-  }
-    ? 1
-    : 2) extends <U>() => U extends {
-    -readonly [V in K]: T[V];
-  }
-    ? 1
-    : 2
-    ? K
-    : never]: T[K];
+    [K in keyof T as (<U>() => U extends {
+        [V in K]: T[V];
+    } ? 1 : 2) extends <U>() => U extends {
+        -readonly [V in K]: T[V];
+    } ? 1 : 2 ? K : never]: T[K];
 };
 export type StorePathRange = {
-  from?: number;
-  to?: number;
-  by?: number;
+    from?: number;
+    to?: number;
+    by?: number;
 };
 export type ArrayFilterFn<T> = (item: T, index: number) => boolean;
-export type StoreSetter<T, U extends PropertyKey[] = []> =
-  | T
-  | CustomPartial<T>
-  | ((prevState: T, traversed: U) => T | CustomPartial<T>);
-export type Part<T, K extends KeyOf<T> = KeyOf<T>> =
-  | K
-  | ([K] extends [never] ? never : readonly K[])
-  | ([T] extends [readonly unknown[]] ? ArrayFilterFn<T[number]> | StorePathRange : never);
+export type StoreSetter<T, U extends PropertyKey[] = []> = T | CustomPartial<T> | ((prevState: T, traversed: U) => T | CustomPartial<T>);
+export type Part<T, K extends KeyOf<T> = KeyOf<T>> = K | ([K] extends [never] ? never : readonly K[]) | ([T] extends [readonly unknown[]] ? ArrayFilterFn<T[number]> | StorePathRange : never);
 type W<T> = Exclude<T, NotWrappable>;
-type KeyOf<T> = number extends keyof T
-  ? 0 extends 1 & T
-    ? keyof T
-    : [T] extends [never]
-    ? never
-    : [T] extends [readonly unknown[]]
-    ? number
-    : keyof T
-  : keyof T;
+type KeyOf<T> = number extends keyof T ? 0 extends 1 & T ? keyof T : [T] extends [never] ? never : [
+    T
+] extends [readonly unknown[]] ? number : keyof T : keyof T;
 type MutableKeyOf<T> = KeyOf<T> & keyof PickMutable<T>;
-type Rest<T, U extends PropertyKey[], K extends KeyOf<T> = KeyOf<T>> = [T] extends [never]
-  ? never
-  : K extends MutableKeyOf<T>
-  ? [Part<T, K>, ...RestSetterOrContinue<T[K], [K, ...U]>]
-  : K extends KeyOf<T>
-  ? [Part<T, K>, ...RestContinue<T[K], [K, ...U]>]
-  : never;
-type RestContinue<T, U extends PropertyKey[]> = 0 extends 1 & T
-  ? [...Part<any>[], StoreSetter<any, PropertyKey[]>]
-  : Rest<W<T>, U>;
+type Rest<T, U extends PropertyKey[], K extends KeyOf<T> = KeyOf<T>> = [T] extends [never] ? never : K extends MutableKeyOf<T> ? [Part<T, K>, ...RestSetterOrContinue<T[K], [K, ...U]>] : K extends KeyOf<T> ? [Part<T, K>, ...RestContinue<T[K], [K, ...U]>] : never;
+type RestContinue<T, U extends PropertyKey[]> = 0 extends 1 & T ? [...Part<any>[], StoreSetter<any, PropertyKey[]>] : Rest<W<T>, U>;
 type RestSetterOrContinue<T, U extends PropertyKey[]> = [StoreSetter<T, U>] | RestContinue<T, U>;
 export interface SetStoreFunction<T> {
-  <
-    K1 extends KeyOf<W<T>>,
-    K2 extends KeyOf<W<W<T>[K1]>>,
-    K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>,
-    K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>,
-    K5 extends KeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>,
-    K6 extends KeyOf<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>>,
-    K7 extends MutableKeyOf<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>>
-  >(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    k3: Part<W<W<W<T>[K1]>[K2]>, K3>,
-    k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>,
-    k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>,
-    k6: Part<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>, K6>,
-    k7: Part<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>, K7>,
-    setter: StoreSetter<
-      W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>[K7],
-      [K7, K6, K5, K4, K3, K2, K1]
-    >
-  ): void;
-  <
-    K1 extends KeyOf<W<T>>,
-    K2 extends KeyOf<W<W<T>[K1]>>,
-    K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>,
-    K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>,
-    K5 extends KeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>,
-    K6 extends MutableKeyOf<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>>
-  >(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    k3: Part<W<W<W<T>[K1]>[K2]>, K3>,
-    k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>,
-    k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>,
-    k6: Part<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>, K6>,
-    setter: StoreSetter<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6], [K6, K5, K4, K3, K2, K1]>
-  ): void;
-  <
-    K1 extends KeyOf<W<T>>,
-    K2 extends KeyOf<W<W<T>[K1]>>,
-    K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>,
-    K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>,
-    K5 extends MutableKeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>
-  >(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    k3: Part<W<W<W<T>[K1]>[K2]>, K3>,
-    k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>,
-    k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>,
-    setter: StoreSetter<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5], [K5, K4, K3, K2, K1]>
-  ): void;
-  <
-    K1 extends KeyOf<W<T>>,
-    K2 extends KeyOf<W<W<T>[K1]>>,
-    K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>,
-    K4 extends MutableKeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>
-  >(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    k3: Part<W<W<W<T>[K1]>[K2]>, K3>,
-    k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>,
-    setter: StoreSetter<W<W<W<W<T>[K1]>[K2]>[K3]>[K4], [K4, K3, K2, K1]>
-  ): void;
-  <
-    K1 extends KeyOf<W<T>>,
-    K2 extends KeyOf<W<W<T>[K1]>>,
-    K3 extends MutableKeyOf<W<W<W<T>[K1]>[K2]>>
-  >(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    k3: Part<W<W<W<T>[K1]>[K2]>, K3>,
-    setter: StoreSetter<W<W<W<T>[K1]>[K2]>[K3], [K3, K2, K1]>
-  ): void;
-  <K1 extends KeyOf<W<T>>, K2 extends MutableKeyOf<W<W<T>[K1]>>>(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    setter: StoreSetter<W<W<T>[K1]>[K2], [K2, K1]>
-  ): void;
-  <K1 extends MutableKeyOf<W<T>>>(k1: Part<W<T>, K1>, setter: StoreSetter<W<T>[K1], [K1]>): void;
-  (setter: StoreSetter<T, []>): void;
-  <
-    K1 extends KeyOf<W<T>>,
-    K2 extends KeyOf<W<W<T>[K1]>>,
-    K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>,
-    K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>,
-    K5 extends KeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>,
-    K6 extends KeyOf<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>>,
-    K7 extends KeyOf<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>>
-  >(
-    k1: Part<W<T>, K1>,
-    k2: Part<W<W<T>[K1]>, K2>,
-    k3: Part<W<W<W<T>[K1]>[K2]>, K3>,
-    k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>,
-    k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>,
-    k6: Part<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>, K6>,
-    k7: Part<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>, K7>,
-    ...rest: Rest<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>[K7], [K7, K6, K5, K4, K3, K2, K1]>
-  ): void;
+    <K1 extends KeyOf<W<T>>, K2 extends KeyOf<W<W<T>[K1]>>, K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>, K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>, K5 extends KeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>, K6 extends KeyOf<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>>, K7 extends MutableKeyOf<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, k3: Part<W<W<W<T>[K1]>[K2]>, K3>, k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>, k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>, k6: Part<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>, K6>, k7: Part<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>, K7>, setter: StoreSetter<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>[K7], [
+        K7,
+        K6,
+        K5,
+        K4,
+        K3,
+        K2,
+        K1
+    ]>): void;
+    <K1 extends KeyOf<W<T>>, K2 extends KeyOf<W<W<T>[K1]>>, K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>, K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>, K5 extends KeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>, K6 extends MutableKeyOf<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, k3: Part<W<W<W<T>[K1]>[K2]>, K3>, k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>, k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>, k6: Part<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>, K6>, setter: StoreSetter<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6], [K6, K5, K4, K3, K2, K1]>): void;
+    <K1 extends KeyOf<W<T>>, K2 extends KeyOf<W<W<T>[K1]>>, K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>, K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>, K5 extends MutableKeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, k3: Part<W<W<W<T>[K1]>[K2]>, K3>, k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>, k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>, setter: StoreSetter<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5], [K5, K4, K3, K2, K1]>): void;
+    <K1 extends KeyOf<W<T>>, K2 extends KeyOf<W<W<T>[K1]>>, K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>, K4 extends MutableKeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, k3: Part<W<W<W<T>[K1]>[K2]>, K3>, k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>, setter: StoreSetter<W<W<W<W<T>[K1]>[K2]>[K3]>[K4], [K4, K3, K2, K1]>): void;
+    <K1 extends KeyOf<W<T>>, K2 extends KeyOf<W<W<T>[K1]>>, K3 extends MutableKeyOf<W<W<W<T>[K1]>[K2]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, k3: Part<W<W<W<T>[K1]>[K2]>, K3>, setter: StoreSetter<W<W<W<T>[K1]>[K2]>[K3], [K3, K2, K1]>): void;
+    <K1 extends KeyOf<W<T>>, K2 extends MutableKeyOf<W<W<T>[K1]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, setter: StoreSetter<W<W<T>[K1]>[K2], [K2, K1]>): void;
+    <K1 extends MutableKeyOf<W<T>>>(k1: Part<W<T>, K1>, setter: StoreSetter<W<T>[K1], [K1]>): void;
+    (setter: StoreSetter<T, []>): void;
+    <K1 extends KeyOf<W<T>>, K2 extends KeyOf<W<W<T>[K1]>>, K3 extends KeyOf<W<W<W<T>[K1]>[K2]>>, K4 extends KeyOf<W<W<W<W<T>[K1]>[K2]>[K3]>>, K5 extends KeyOf<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>>, K6 extends KeyOf<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>>, K7 extends KeyOf<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>>>(k1: Part<W<T>, K1>, k2: Part<W<W<T>[K1]>, K2>, k3: Part<W<W<W<T>[K1]>[K2]>, K3>, k4: Part<W<W<W<W<T>[K1]>[K2]>[K3]>, K4>, k5: Part<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>, K5>, k6: Part<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>, K6>, k7: Part<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>, K7>, ...rest: Rest<W<W<W<W<W<W<W<T>[K1]>[K2]>[K3]>[K4]>[K5]>[K6]>[K7], [K7, K6, K5, K4, K3, K2, K1]>): void;
 }
 /**
  * Creates a reactive store that can be read through a proxy object and written with a setter function
  *
  * @description https://docs.solidjs.com/reference/store-utilities/create-store
  */
-export declare function createStore<T extends object = {}>(
-  ...[store, options]: {} extends T
-    ? [
-        store?: T | Store<T>,
-        options?: {
-          name?: string;
-        }
-      ]
-    : [
-        store: T | Store<T>,
-        options?: {
-          name?: string;
-        }
-      ]
-): [get: Store<T>, set: SetStoreFunction<T>];
+export declare function createStore<T extends object = {}>(...[store, options]: {} extends T ? [store?: T | Store<T>, options?: {
+    name?: string;
+}] : [store: T | Store<T>, options?: {
+    name?: string;
+}]): [get: Store<T>, set: SetStoreFunction<T>];
 export {};
diff --git a/types/index.d.ts b/types/index.d.ts
index e93ca31f7a0db0e0aa0185cc86b155d903806e05..4bb20d6caf6f7c8fd895665c2055fe4b1019663f 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -1,66 +1,5 @@
-export {
-  $DEVCOMP,
-  $PROXY,
-  $TRACK,
-  batch,
-  catchError,
-  children,
-  createComputed,
-  createContext,
-  createDeferred,
-  createEffect,
-  createMemo,
-  createReaction,
-  createRenderEffect,
-  createResource,
-  createRoot,
-  createSelector,
-  createSignal,
-  enableExternalSource,
-  enableScheduling,
-  equalFn,
-  getListener,
-  getOwner,
-  on,
-  onCleanup,
-  onError,
-  onMount,
-  runWithOwner,
-  startTransition,
-  untrack,
-  useContext,
-  useTransition
-} from "./reactive/signal.js";
-export type {
-  Accessor,
-  AccessorArray,
-  ChildrenReturn,
-  Context,
-  ContextProviderComponent,
-  EffectFunction,
-  EffectOptions,
-  InitializedResource,
-  InitializedResourceOptions,
-  InitializedResourceReturn,
-  MemoOptions,
-  NoInfer,
-  OnEffectFunction,
-  OnOptions,
-  Owner,
-  ResolvedChildren,
-  ResolvedJSXElement,
-  Resource,
-  ResourceActions,
-  ResourceFetcher,
-  ResourceFetcherInfo,
-  ResourceOptions,
-  ResourceReturn,
-  ResourceSource,
-  ReturnTypes,
-  Setter,
-  Signal,
-  SignalOptions
-} from "./reactive/signal.js";
+export { $DEVCOMP, $PROXY, $TRACK, batch, catchError, children, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, enableExternalSource, enableScheduling, equalFn, getListener, getOwner, on, onCleanup, onError, onMount, runWithOwner, startTransition, untrack, useContext, useTransition } from "./reactive/signal.js";
+export type { Accessor, AccessorArray, ChildrenReturn, Context, ContextProviderComponent, EffectFunction, EffectOptions, InitializedResource, InitializedResourceOptions, InitializedResourceReturn, MemoOptions, NoInfer, OnEffectFunction, OnOptions, Owner, ResolvedChildren, ResolvedJSXElement, Resource, ResourceActions, ResourceFetcher, ResourceFetcherInfo, ResourceOptions, ResourceReturn, ResourceSource, ReturnTypes, Setter, Signal, SignalOptions } from "./reactive/signal.js";
 export * from "./reactive/observable.js";
 export * from "./reactive/scheduler.js";
 export * from "./reactive/array.js";
@@ -68,20 +7,43 @@ export * from "./render/index.js";
 import type { JSX } from "./jsx.js";
 type JSXElement = JSX.Element;
 export type { JSXElement, JSX };
-import { registerGraph, writeSignal } from "./reactive/signal.js";
-export declare const DEV:
-  | {
-      readonly hooks: {
+import * as signal from "./reactive/signal.js";
+/**
+ * Development-only solid-js apis exposed for debugging,
+ * `undefined` in production or on the server.
+ */
+export declare const DEV: {
+    /** currect version of solid-js  */
+    readonly version: "SOLID_VERSION";
+    readonly getOwner: typeof signal.getOwner;
+    readonly getListener: typeof signal.getListener;
+    readonly $PROXY: typeof signal.$PROXY;
+    readonly $DEVCOMP: typeof signal.$DEVCOMP;
+    readonly $TRACK: typeof signal.$TRACK;
+    readonly hooks: {
         afterUpdate: (() => void) | null;
-        afterCreateOwner: ((owner: import("./reactive/signal.js").Owner) => void) | null;
-        afterCreateSignal:
-          | ((signal: import("./reactive/signal.js").SignalState<any>) => void)
-          | null;
-      };
-      readonly writeSignal: typeof writeSignal;
-      readonly registerGraph: typeof registerGraph;
-    }
-  | undefined;
+        afterCreateOwner: ((owner: signal.Owner) => void) | null;
+        afterCreateSignal: ((signal: signal.SignalState<any>) => void) | null;
+    };
+    readonly readSignal: typeof signal.readSignal;
+    readonly writeSignal: typeof signal.writeSignal;
+    readonly registerGraph: typeof signal.registerGraph;
+    readonly sharedConfig: {
+        context?: import("./render/hydration.js").HydrationContext;
+        resources?: {
+            [key: string]: any;
+        };
+        load?: (id: string) => Promise<any> | any;
+        has?: (id: string) => boolean;
+        gather?: (key: string) => void;
+        registry?: Map<string, Element>;
+        done?: boolean;
+        count?: number;
+        effects?: signal.Computation<any, any>[];
+        getContextId(): string;
+        getNextContextId(): string;
+    };
+} | undefined;
 declare global {
-  var Solid$$: boolean;
+    var Solid$$: undefined | typeof DEV;
 }
diff --git a/types/jsx.d.ts b/types/jsx.d.ts
index 2852436e1be7a3cfa713d90d5919349d6f31dcde..e7f494787b9bc1d3e5c3dd4a0d73db549d630768 100644
--- a/types/jsx.d.ts
+++ b/types/jsx.d.ts
@@ -30,29 +30,30 @@ export namespace JSX {
   }
 
   interface BoundEventHandler<
-    T,
-    E extends Event,
-    EHandler extends EventHandler<T, any> = EventHandler<T, E>
+      T,
+      E extends Event,
+      EHandler extends EventHandler<T, any> = EventHandler<T, E>,
   > {
-    0: (data: any, ...e: Parameters<EHandler>) => void;
+    0: (
+      data: any,
+      ...e: Parameters<EHandler>,
+    ) => void;
     1: any;
   }
   type EventHandlerUnion<
     T,
     E extends Event,
-    EHandler extends EventHandler<T, any> = EventHandler<T, E>
+    EHandler extends EventHandler<T, any> = EventHandler<T, E>,
   > = EHandler | BoundEventHandler<T, E, EHandler>;
 
   interface EventHandlerWithOptions<T, E extends Event, EHandler = EventHandler<T, E>>
-    extends AddEventListenerOptions {
+      extends AddEventListenerOptions {
     handleEvent: EHandler;
   }
 
-  type EventHandlerWithOptionsUnion<
-    T,
-    E extends Event,
-    EHandler extends EventHandler<T, any> = EventHandler<T, E>
-  > = EHandler | EventHandlerWithOptions<T, E, EHandler>;
+  type EventHandlerWithOptionsUnion<T, E extends Event, EHandler extends EventHandler<T, any> = EventHandler<T, E>> =
+    | EHandler
+    | EventHandlerWithOptions<T, E, EHandler>;
 
   interface InputEventHandler<T, E extends InputEvent> {
     (
@@ -64,11 +65,7 @@ export namespace JSX {
       }
     ): void;
   }
-  type InputEventHandlerUnion<T, E extends InputEvent> = EventHandlerUnion<
-    T,
-    E,
-    InputEventHandler<T, E>
-  >;
+  type InputEventHandlerUnion<T, E extends InputEvent> = EventHandlerUnion<T, E, InputEventHandler<T, E>>;
 
   interface ChangeEventHandler<T, E extends Event> {
     (
@@ -80,11 +77,7 @@ export namespace JSX {
       }
     ): void;
   }
-  type ChangeEventHandlerUnion<T, E extends Event> = EventHandlerUnion<
-    T,
-    E,
-    ChangeEventHandler<T, E>
-  >;
+  type ChangeEventHandlerUnion<T, E extends Event> = EventHandlerUnion<T, E, ChangeEventHandler<T, E>>;
 
   interface FocusEventHandler<T, E extends FocusEvent> {
     (
@@ -96,11 +89,7 @@ export namespace JSX {
       }
     ): void;
   }
-  type FocusEventHandlerUnion<T, E extends FocusEvent> = EventHandlerUnion<
-    T,
-    E,
-    FocusEventHandler<T, E>
-  >;
+  type FocusEventHandlerUnion<T, E extends FocusEvent> = EventHandlerUnion<T, E, FocusEventHandler<T, E>>;
 
   const SERIALIZABLE: unique symbol;
   interface SerializableAttributeValue {
@@ -113,11 +102,9 @@ export namespace JSX {
   }
   interface CustomAttributes<T> {
     ref?: T | ((el: T) => void) | undefined;
-    classList?:
-      | {
-          [k: string]: boolean | undefined;
-        }
-      | undefined;
+    classList?: {
+      [k: string]: boolean | undefined;
+    } | undefined;
     $ServerOnly?: boolean | undefined;
   }
   type Accessor<T> = () => T;
@@ -214,11 +201,9 @@ export namespace JSX {
     "on:compositionstart"?: EventHandlerWithOptionsUnion<T, CompositionEvent> | undefined;
     "on:compositionupdate"?: EventHandlerWithOptionsUnion<T, CompositionEvent> | undefined;
     "on:focusout"?:
-      | EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>>
-      | undefined;
+      EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>> | undefined;
     "on:focusin"?:
-      | EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>>
-      | undefined;
+      EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>> | undefined;
     "on:encrypted"?: EventHandlerWithOptionsUnion<T, Event> | undefined;
     "on:dragexit"?: EventHandlerWithOptionsUnion<T, DragEvent> | undefined;
   }
@@ -392,12 +377,10 @@ export namespace JSX {
     "on:animationstart"?: EventHandlerWithOptionsUnion<T, AnimationEvent> | undefined;
     "on:auxclick"?: EventHandlerWithOptionsUnion<T, MouseEvent> | undefined;
     "on:beforeinput"?:
-      | EventHandlerWithOptionsUnion<T, InputEvent, InputEventHandler<T, InputEvent>>
-      | undefined;
+      EventHandlerWithOptionsUnion<T, InputEvent, InputEventHandler<T, InputEvent>> | undefined;
     "on:beforetoggle"?: EventHandlerWithOptionsUnion<T, ToggleEvent> | undefined;
     "on:blur"?:
-      | EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>>
-      | undefined;
+      EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>> | undefined;
     "on:canplay"?: EventHandlerWithOptionsUnion<T, Event> | undefined;
     "on:canplaythrough"?: EventHandlerWithOptionsUnion<T, Event> | undefined;
     "on:change"?: EventHandlerWithOptionsUnion<T, Event, ChangeEventHandler<T, Event>> | undefined;
@@ -416,12 +399,10 @@ export namespace JSX {
     "on:ended"?: EventHandlerWithOptionsUnion<T, Event> | undefined;
     "on:error"?: EventHandlerWithOptionsUnion<T, Event> | undefined;
     "on:focus"?:
-      | EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>>
-      | undefined;
+      EventHandlerWithOptionsUnion<T, FocusEvent, FocusEventHandler<T, FocusEvent>> | undefined;
     "on:gotpointercapture"?: EventHandlerWithOptionsUnion<T, PointerEvent> | undefined;
     "on:input"?:
-      | EventHandlerWithOptionsUnion<T, InputEvent, InputEventHandler<T, InputEvent>>
-      | undefined;
+      EventHandlerWithOptionsUnion<T, InputEvent, InputEventHandler<T, InputEvent>> | undefined;
     "on:invalid"?: EventHandlerWithOptionsUnion<T, Event> | undefined;
     "on:keydown"?: EventHandlerWithOptionsUnion<T, KeyboardEvent> | undefined;
     "on:keypress"?: EventHandlerWithOptionsUnion<T, KeyboardEvent> | undefined;
diff --git a/types/reactive/array.d.ts b/types/reactive/array.d.ts
index 379c23003e2b4fcd834e4375185e184014ba1773..2c27781ee86aa75212472087f0232b646022a06e 100644
--- a/types/reactive/array.d.ts
+++ b/types/reactive/array.d.ts
@@ -29,13 +29,9 @@ SOFTWARE.
  *
  * @description https://docs.solidjs.com/reference/reactive-utilities/map-array
  */
-export declare function mapArray<T, U>(
-  list: Accessor<readonly T[] | undefined | null | false>,
-  mapFn: (v: T, i: Accessor<number>) => U,
-  options?: {
+export declare function mapArray<T, U>(list: Accessor<readonly T[] | undefined | null | false>, mapFn: (v: T, i: Accessor<number>) => U, options?: {
     fallback?: Accessor<any>;
-  }
-): () => U[];
+}): () => U[];
 /**
  * Reactively maps arrays by index instead of value - underlying helper for the `<Index>` control flow
  *
@@ -43,10 +39,6 @@ export declare function mapArray<T, U>(
  *
  * @description https://docs.solidjs.com/reference/reactive-utilities/index-array
  */
-export declare function indexArray<T, U>(
-  list: Accessor<readonly T[] | undefined | null | false>,
-  mapFn: (v: Accessor<T>, i: number) => U,
-  options?: {
+export declare function indexArray<T, U>(list: Accessor<readonly T[] | undefined | null | false>, mapFn: (v: Accessor<T>, i: number) => U, options?: {
     fallback?: Accessor<any>;
-  }
-): () => U[];
+}): () => U[];
diff --git a/types/reactive/observable.d.ts b/types/reactive/observable.d.ts
index cc16ce45d1c7cffd1e66551cac313d9af043545d..cbf4832d23dd9c1de9408d562edebc78246c5319 100644
--- a/types/reactive/observable.d.ts
+++ b/types/reactive/observable.d.ts
@@ -1,22 +1,20 @@
 import { Accessor, Setter } from "./signal.js";
 declare global {
-  interface SymbolConstructor {
-    readonly observable: symbol;
-  }
+    interface SymbolConstructor {
+        readonly observable: symbol;
+    }
 }
 interface Observable<T> {
-  subscribe(observer: ObservableObserver<T>): {
-    unsubscribe(): void;
-  };
-  [Symbol.observable](): Observable<T>;
-}
-export type ObservableObserver<T> =
-  | ((v: T) => void)
-  | {
-      next?: (v: T) => void;
-      error?: (v: any) => void;
-      complete?: (v: boolean) => void;
+    subscribe(observer: ObservableObserver<T>): {
+        unsubscribe(): void;
     };
+    [Symbol.observable](): Observable<T>;
+}
+export type ObservableObserver<T> = ((v: T) => void) | {
+    next?: (v: T) => void;
+    error?: (v: any) => void;
+    complete?: (v: boolean) => void;
+};
 /**
  * Creates a simple observable from a signal's accessor to be used with the `from` operator of observable libraries like e.g. rxjs
  * ```typescript
@@ -28,15 +26,9 @@ export type ObservableObserver<T> =
  * description https://docs.solidjs.com/reference/reactive-utilities/observable
  */
 export declare function observable<T>(input: Accessor<T>): Observable<T>;
-export declare function from<T>(
-  producer:
-    | ((setter: Setter<T | undefined>) => () => void)
-    | {
-        subscribe: (fn: (v: T) => void) =>
-          | (() => void)
-          | {
-              unsubscribe: () => void;
-            };
-      }
-): Accessor<T | undefined>;
+export declare function from<T>(producer: ((setter: Setter<T | undefined>) => () => void) | {
+    subscribe: (fn: (v: T) => void) => (() => void) | {
+        unsubscribe: () => void;
+    };
+}): Accessor<T | undefined>;
 export {};
diff --git a/types/reactive/scheduler.d.ts b/types/reactive/scheduler.d.ts
index b4948c1ff20b4bfb7dd092de1e0f164f756bbb8b..a915c542fbbac2060fdf62d5e4366d11abeefd5a 100644
--- a/types/reactive/scheduler.d.ts
+++ b/types/reactive/scheduler.d.ts
@@ -1,13 +1,10 @@
 export interface Task {
-  id: number;
-  fn: ((didTimeout: boolean) => void) | null;
-  startTime: number;
-  expirationTime: number;
+    id: number;
+    fn: ((didTimeout: boolean) => void) | null;
+    startTime: number;
+    expirationTime: number;
 }
-export declare function requestCallback(
-  fn: () => void,
-  options?: {
+export declare function requestCallback(fn: () => void, options?: {
     timeout: number;
-  }
-): Task;
+}): Task;
 export declare function cancelCallback(task: Task): void;
diff --git a/types/reactive/signal.d.ts b/types/reactive/signal.d.ts
index e7b46675f0f48123f6605ad21e431d7a0d2cf40a..3abae5f2ca1ff312abafb467440aaed323baf95a 100644
--- a/types/reactive/signal.d.ts
+++ b/types/reactive/signal.d.ts
@@ -33,61 +33,58 @@ export declare var Owner: Owner | null;
 export declare let Transition: TransitionState | null;
 /** Object storing callbacks for debugging during development */
 export declare const DevHooks: {
-  afterUpdate: (() => void) | null;
-  afterCreateOwner: ((owner: Owner) => void) | null;
-  afterCreateSignal: ((signal: SignalState<any>) => void) | null;
+    afterUpdate: (() => void) | null;
+    afterCreateOwner: ((owner: Owner) => void) | null;
+    afterCreateSignal: ((signal: SignalState<any>) => void) | null;
 };
 export type ComputationState = 0 | 1 | 2;
 export interface SourceMapValue {
-  value: unknown;
-  name?: string;
-  graph?: Owner;
+    value: unknown;
+    name?: string;
+    graph?: Owner;
 }
 export interface SignalState<T> extends SourceMapValue {
-  value: T;
-  observers: Computation<any>[] | null;
-  observerSlots: number[] | null;
-  tValue?: T;
-  comparator?: (prev: T, next: T) => boolean;
+    value: T;
+    observers: Computation<any>[] | null;
+    observerSlots: number[] | null;
+    tValue?: T;
+    comparator?: (prev: T, next: T) => boolean;
 }
 export interface Owner {
-  owned: Computation<any>[] | null;
-  cleanups: (() => void)[] | null;
-  owner: Owner | null;
-  context: any | null;
-  sourceMap?: SourceMapValue[];
-  name?: string;
+    owned: Computation<any>[] | null;
+    cleanups: (() => void)[] | null;
+    owner: Owner | null;
+    context: any | null;
+    sourceMap?: SourceMapValue[];
+    name?: string;
 }
 export interface Computation<Init, Next extends Init = Init> extends Owner {
-  fn: EffectFunction<Init, Next>;
-  state: ComputationState;
-  tState?: ComputationState;
-  sources: SignalState<Next>[] | null;
-  sourceSlots: number[] | null;
-  value?: Init;
-  updatedAt: number | null;
-  pure: boolean;
-  user?: boolean;
-  suspense?: SuspenseContextType;
+    fn: EffectFunction<Init, Next>;
+    state: ComputationState;
+    tState?: ComputationState;
+    sources: SignalState<Next>[] | null;
+    sourceSlots: number[] | null;
+    value?: Init;
+    updatedAt: number | null;
+    pure: boolean;
+    user?: boolean;
+    suspense?: SuspenseContextType;
 }
 export interface TransitionState {
-  sources: Set<SignalState<any>>;
-  effects: Computation<any>[];
-  promises: Set<Promise<any>>;
-  disposed: Set<Computation<any>>;
-  queue: Set<Computation<any>>;
-  scheduler?: (fn: () => void) => unknown;
-  running: boolean;
-  done?: Promise<void>;
-  resolve?: () => void;
+    sources: Set<SignalState<any>>;
+    effects: Computation<any>[];
+    promises: Set<Promise<any>>;
+    disposed: Set<Computation<any>>;
+    queue: Set<Computation<any>>;
+    scheduler?: (fn: () => void) => unknown;
+    running: boolean;
+    done?: Promise<void>;
+    resolve?: () => void;
 }
-type ExternalSourceFactory = <Prev, Next extends Prev = Prev>(
-  fn: EffectFunction<Prev, Next>,
-  trigger: () => void
-) => ExternalSource;
+type ExternalSourceFactory = <Prev, Next extends Prev = Prev>(fn: EffectFunction<Prev, Next>, trigger: () => void) => ExternalSource;
 export interface ExternalSource {
-  track: EffectFunction<any, any>;
-  dispose: () => void;
+    track: EffectFunction<any, any>;
+    dispose: () => void;
 }
 export type RootFunction<T> = (dispose: () => void) => T;
 /**
@@ -102,16 +99,14 @@ export type RootFunction<T> = (dispose: () => void) => T;
 export declare function createRoot<T>(fn: RootFunction<T>, detachedOwner?: typeof Owner): T;
 export type Accessor<T> = () => T;
 export type Setter<in out T> = {
-  <U extends T>(
-    ...args: undefined extends T ? [] : [value: Exclude<U, Function> | ((prev: T) => U)]
-  ): undefined extends T ? undefined : U;
-  <U extends T>(value: (prev: T) => U): U;
-  <U extends T>(value: Exclude<U, Function>): U;
-  <U extends T>(value: Exclude<U, Function> | ((prev: T) => U)): U;
+    <U extends T>(...args: undefined extends T ? [] : [value: Exclude<U, Function> | ((prev: T) => U)]): undefined extends T ? undefined : U;
+    <U extends T>(value: (prev: T) => U): U;
+    <U extends T>(value: Exclude<U, Function>): U;
+    <U extends T>(value: Exclude<U, Function> | ((prev: T) => U)): U;
 };
 export type Signal<T> = [get: Accessor<T>, set: Setter<T>];
 export interface SignalOptions<T> extends MemoOptions<T> {
-  internal?: boolean;
+    internal?: boolean;
 }
 /**
  * Creates a simple reactive state with a getter and setter
@@ -139,10 +134,11 @@ export interface SignalOptions<T> extends MemoOptions<T> {
 export declare function createSignal<T>(): Signal<T | undefined>;
 export declare function createSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;
 export interface BaseOptions {
-  name?: string;
+    name?: string;
 }
 export type NoInfer<T extends any> = [T][T extends any ? 0 : never];
-export interface EffectOptions extends BaseOptions {}
+export interface EffectOptions extends BaseOptions {
+}
 export type EffectFunction<Prev, Next extends Prev = Prev> = (v: Prev) => Next;
 /**
  * Creates a reactive computation that runs immediately before render, mainly used to write to other reactive primitives
@@ -159,14 +155,8 @@ export type EffectFunction<Prev, Next extends Prev = Prev> = (v: Prev) => Next;
  *
  * @description https://docs.solidjs.com/reference/secondary-primitives/create-computed
  */
-export declare function createComputed<Next>(
-  fn: EffectFunction<undefined | NoInfer<Next>, Next>
-): void;
-export declare function createComputed<Next, Init = Next>(
-  fn: EffectFunction<Init | Next, Next>,
-  value: Init,
-  options?: EffectOptions
-): void;
+export declare function createComputed<Next>(fn: EffectFunction<undefined | NoInfer<Next>, Next>): void;
+export declare function createComputed<Next, Init = Next>(fn: EffectFunction<Init | Next, Next>, value: Init, options?: EffectOptions): void;
 /**
  * Creates a reactive computation that runs during the render phase as DOM elements are created and updated but not necessarily connected
  * ```typescript
@@ -182,14 +172,8 @@ export declare function createComputed<Next, Init = Next>(
  *
  * @description https://docs.solidjs.com/reference/secondary-primitives/create-render-effect
  */
-export declare function createRenderEffect<Next>(
-  fn: EffectFunction<undefined | NoInfer<Next>, Next>
-): void;
-export declare function createRenderEffect<Next, Init = Next>(
-  fn: EffectFunction<Init | Next, Next>,
-  value: Init,
-  options?: EffectOptions
-): void;
+export declare function createRenderEffect<Next>(fn: EffectFunction<undefined | NoInfer<Next>, Next>): void;
+export declare function createRenderEffect<Next, Init = Next>(fn: EffectFunction<Init | Next, Next>, value: Init, options?: EffectOptions): void;
 /**
  * Creates a reactive computation that runs after the render phase
  * ```typescript
@@ -205,16 +189,10 @@ export declare function createRenderEffect<Next, Init = Next>(
  *
  * @description https://docs.solidjs.com/reference/basic-reactivity/create-effect
  */
-export declare function createEffect<Next>(
-  fn: EffectFunction<undefined | NoInfer<Next>, Next>
-): void;
-export declare function createEffect<Next, Init = Next>(
-  fn: EffectFunction<Init | Next, Next>,
-  value: Init,
-  options?: EffectOptions & {
+export declare function createEffect<Next>(fn: EffectFunction<undefined | NoInfer<Next>, Next>): void;
+export declare function createEffect<Next, Init = Next>(fn: EffectFunction<Init | Next, Next>, value: Init, options?: EffectOptions & {
     render?: boolean;
-  }
-): void;
+}): void;
 /**
  * Creates a reactive computation that runs after the render phase with flexible tracking
  * ```typescript
@@ -228,16 +206,13 @@ export declare function createEffect<Next, Init = Next>(
  *
  * @description https://docs.solidjs.com/reference/secondary-primitives/create-reaction
  */
-export declare function createReaction(
-  onInvalidate: () => void,
-  options?: EffectOptions
-): (tracking: () => void) => void;
+export declare function createReaction(onInvalidate: () => void, options?: EffectOptions): (tracking: () => void) => void;
 export interface Memo<Prev, Next = Prev> extends SignalState<Next>, Computation<Next> {
-  value: Next;
-  tOwned?: Computation<Prev | Next, Next>[];
+    value: Next;
+    tOwned?: Computation<Prev | Next, Next>[];
 }
 export interface MemoOptions<T> extends EffectOptions {
-  equals?: false | ((prev: T, next: T) => boolean);
+    equals?: false | ((prev: T, next: T) => boolean);
 }
 /**
  * Creates a readonly derived reactive memoized signal
@@ -254,84 +229,72 @@ export interface MemoOptions<T> extends EffectOptions {
  *
  * @description https://docs.solidjs.com/reference/basic-reactivity/create-memo
  */
-export declare function createMemo<Next extends Prev, Prev = Next>(
-  fn: EffectFunction<undefined | NoInfer<Prev>, Next>
-): Accessor<Next>;
-export declare function createMemo<Next extends Prev, Init = Next, Prev = Next>(
-  fn: EffectFunction<Init | Prev, Next>,
-  value: Init,
-  options?: MemoOptions<Next>
-): Accessor<Next>;
+export declare function createMemo<Next extends Prev, Prev = Next>(fn: EffectFunction<undefined | NoInfer<Prev>, Next>): Accessor<Next>;
+export declare function createMemo<Next extends Prev, Init = Next, Prev = Next>(fn: EffectFunction<Init | Prev, Next>, value: Init, options?: MemoOptions<Next>): Accessor<Next>;
 interface Unresolved {
-  state: "unresolved";
-  loading: false;
-  error: undefined;
-  latest: undefined;
-  (): undefined;
+    state: "unresolved";
+    loading: false;
+    error: undefined;
+    latest: undefined;
+    (): undefined;
 }
 interface Pending {
-  state: "pending";
-  loading: true;
-  error: undefined;
-  latest: undefined;
-  (): undefined;
+    state: "pending";
+    loading: true;
+    error: undefined;
+    latest: undefined;
+    (): undefined;
 }
 interface Ready<T> {
-  state: "ready";
-  loading: false;
-  error: undefined;
-  latest: T;
-  (): T;
+    state: "ready";
+    loading: false;
+    error: undefined;
+    latest: T;
+    (): T;
 }
 interface Refreshing<T> {
-  state: "refreshing";
-  loading: true;
-  error: undefined;
-  latest: T;
-  (): T;
+    state: "refreshing";
+    loading: true;
+    error: undefined;
+    latest: T;
+    (): T;
 }
 interface Errored {
-  state: "errored";
-  loading: false;
-  error: any;
-  latest: never;
-  (): never;
+    state: "errored";
+    loading: false;
+    error: any;
+    latest: never;
+    (): never;
 }
 export type Resource<T> = Unresolved | Pending | Ready<T> | Refreshing<T> | Errored;
 export type InitializedResource<T> = Ready<T> | Refreshing<T> | Errored;
 export type ResourceActions<T, R = unknown> = {
-  mutate: Setter<T>;
-  refetch: (info?: R) => T | Promise<T> | undefined | null;
+    mutate: Setter<T>;
+    refetch: (info?: R) => T | Promise<T> | undefined | null;
 };
 export type ResourceSource<S> = S | false | null | undefined | (() => S | false | null | undefined);
-export type ResourceFetcher<S, T, R = unknown> = (
-  k: S,
-  info: ResourceFetcherInfo<T, R>
-) => T | Promise<T>;
+export type ResourceFetcher<S, T, R = unknown> = (k: S, info: ResourceFetcherInfo<T, R>) => T | Promise<T>;
 export type ResourceFetcherInfo<T, R = unknown> = {
-  value: T | undefined;
-  refetching: R | boolean;
+    value: T | undefined;
+    refetching: R | boolean;
 };
 export type ResourceOptions<T, S = unknown> = {
-  initialValue?: T;
-  name?: string;
-  deferStream?: boolean;
-  ssrLoadFrom?: "initial" | "server";
-  storage?: (init: T | undefined) => [Accessor<T | undefined>, Setter<T | undefined>];
-  onHydrated?: (
-    k: S | undefined,
-    info: {
-      value: T | undefined;
-    }
-  ) => void;
+    initialValue?: T;
+    name?: string;
+    deferStream?: boolean;
+    ssrLoadFrom?: "initial" | "server";
+    storage?: (init: T | undefined) => [Accessor<T | undefined>, Setter<T | undefined>];
+    onHydrated?: (k: S | undefined, info: {
+        value: T | undefined;
+    }) => void;
 };
 export type InitializedResourceOptions<T, S = unknown> = ResourceOptions<T, S> & {
-  initialValue: T;
+    initialValue: T;
 };
 export type ResourceReturn<T, R = unknown> = [Resource<T>, ResourceActions<T | undefined, R>];
 export type InitializedResourceReturn<T, R = unknown> = [
-  InitializedResource<T>,
-  ResourceActions<T, R>
+    InitializedResource<T>,
+    ResourceActions<T, R>
 ];
 /**
  * Creates a resource that wraps a repeated promise in a reactive pattern:
@@ -361,28 +324,14 @@ export type InitializedResourceReturn<T, R = unknown> = [
  *
  * @description https://docs.solidjs.com/reference/basic-reactivity/create-resource
  */
-export declare function createResource<T, R = unknown>(
-  fetcher: ResourceFetcher<true, T, R>,
-  options: InitializedResourceOptions<NoInfer<T>, true>
-): InitializedResourceReturn<T, R>;
-export declare function createResource<T, R = unknown>(
-  fetcher: ResourceFetcher<true, T, R>,
-  options?: ResourceOptions<NoInfer<T>, true>
-): ResourceReturn<T, R>;
-export declare function createResource<T, S, R = unknown>(
-  source: ResourceSource<S>,
-  fetcher: ResourceFetcher<S, T, R>,
-  options: InitializedResourceOptions<NoInfer<T>, S>
-): InitializedResourceReturn<T, R>;
-export declare function createResource<T, S, R = unknown>(
-  source: ResourceSource<S>,
-  fetcher: ResourceFetcher<S, T, R>,
-  options?: ResourceOptions<NoInfer<T>, S>
-): ResourceReturn<T, R>;
+export declare function createResource<T, R = unknown>(fetcher: ResourceFetcher<true, T, R>, options: InitializedResourceOptions<NoInfer<T>, true>): InitializedResourceReturn<T, R>;
+export declare function createResource<T, R = unknown>(fetcher: ResourceFetcher<true, T, R>, options?: ResourceOptions<NoInfer<T>, true>): ResourceReturn<T, R>;
+export declare function createResource<T, S, R = unknown>(source: ResourceSource<S>, fetcher: ResourceFetcher<S, T, R>, options: InitializedResourceOptions<NoInfer<T>, S>): InitializedResourceReturn<T, R>;
+export declare function createResource<T, S, R = unknown>(source: ResourceSource<S>, fetcher: ResourceFetcher<S, T, R>, options?: ResourceOptions<NoInfer<T>, S>): ResourceReturn<T, R>;
 export interface DeferredOptions<T> {
-  equals?: false | ((prev: T, next: T) => boolean);
-  name?: string;
-  timeoutMs?: number;
+    equals?: false | ((prev: T, next: T) => boolean);
+    name?: string;
+    timeoutMs?: number;
 }
 /**
  * Creates a reactive computation that only runs and notifies the reactive context when the browser is idle
@@ -397,10 +346,7 @@ export interface DeferredOptions<T> {
  *
  * @description https://docs.solidjs.com/reference/secondary-primitives/create-deferred
  */
-export declare function createDeferred<T>(
-  source: Accessor<T>,
-  options?: DeferredOptions<T>
-): Accessor<T>;
+export declare function createDeferred<T>(source: Accessor<T>, options?: DeferredOptions<T>): Accessor<T>;
 export type EqualityCheckerFunction<T, U> = (a: U, b: T) => boolean;
 /**
  * Creates a conditional signal that only notifies subscribers when entering or exiting their key matching the value
@@ -426,11 +372,7 @@ export type EqualityCheckerFunction<T, U> = (a: U, b: T) => boolean;
  *
  * @description https://docs.solidjs.com/reference/secondary-primitives/create-selector
  */
-export declare function createSelector<T, U = T>(
-  source: Accessor<T>,
-  fn?: EqualityCheckerFunction<T, U>,
-  options?: BaseOptions
-): (key: U) => boolean;
+export declare function createSelector<T, U = T>(source: Accessor<T>, fn?: EqualityCheckerFunction<T, U>, options?: BaseOptions): (key: U) => boolean;
 /**
  * Holds changes inside the block before the reactive context is updated
  * @param fn wraps the reactive updates that should be batched
@@ -448,28 +390,15 @@ export declare function batch<T>(fn: Accessor<T>): T;
  */
 export declare function untrack<T>(fn: Accessor<T>): T;
 /** @deprecated */
-export type ReturnTypes<T> = T extends readonly Accessor<unknown>[]
-  ? {
-      [K in keyof T]: T[K] extends Accessor<infer I> ? I : never;
-    }
-  : T extends Accessor<infer I>
-  ? I
-  : never;
-export type AccessorArray<T> = [
-  ...Extract<
-    {
-      [K in keyof T]: Accessor<T[K]>;
-    },
-    readonly unknown[]
-  >
-];
-export type OnEffectFunction<S, Prev, Next extends Prev = Prev> = (
-  input: S,
-  prevInput: S | undefined,
-  prev: Prev
-) => Next;
+export type ReturnTypes<T> = T extends readonly Accessor<unknown>[] ? {
+    [K in keyof T]: T[K] extends Accessor<infer I> ? I : never;
+} : T extends Accessor<infer I> ? I : never;
+export type AccessorArray<T> = [...Extract<{
+    [K in keyof T]: Accessor<T[K]>;
+}, readonly unknown[]>];
+export type OnEffectFunction<S, Prev, Next extends Prev = Prev> = (input: S, prevInput: S | undefined, prev: Prev) => Next;
 export interface OnOptions {
-  defer?: boolean;
+    defer?: boolean;
 }
 /**
  * Makes dependencies of a computation explicit
@@ -497,22 +426,12 @@ export interface OnOptions {
  *
  * @description https://docs.solidjs.com/reference/reactive-utilities/on
  */
-export declare function on<S, Next extends Prev, Prev = Next>(
-  deps: AccessorArray<S> | Accessor<S>,
-  fn: OnEffectFunction<S, undefined | NoInfer<Prev>, Next>,
-  options?: OnOptions & {
+export declare function on<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: OnEffectFunction<S, undefined | NoInfer<Prev>, Next>, options?: OnOptions & {
     defer?: false;
-  }
-): EffectFunction<undefined | NoInfer<Next>, NoInfer<Next>>;
-export declare function on<S, Next extends Prev, Prev = Next>(
-  deps: AccessorArray<S> | Accessor<S>,
-  fn: OnEffectFunction<S, undefined | NoInfer<Prev>, Next>,
-  options:
-    | OnOptions
-    | {
-        defer: true;
-      }
-): EffectFunction<undefined | NoInfer<Next>>;
+}): EffectFunction<undefined | NoInfer<Next>, NoInfer<Next>>;
+export declare function on<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: OnEffectFunction<S, undefined | NoInfer<Prev>, Next>, options: OnOptions | {
+    defer: true;
+}): EffectFunction<undefined | NoInfer<Next>>;
 /**
  * Runs an effect only after initial render on mount
  * @param fn an effect that should run only once on mount
@@ -566,19 +485,19 @@ export type Transition = [Accessor<boolean>, (fn: () => void) => Promise<void>];
 export declare function useTransition(): Transition;
 export declare function resumeEffects(e: Computation<any>[]): void;
 export interface DevComponent<T> extends Memo<unknown> {
-  props: T;
-  name: string;
-  component: (props: T) => unknown;
+    props: T;
+    name: string;
+    component: (props: T) => unknown;
 }
 export declare function devComponent<P, V>(Comp: (props: P) => V, props: P): V;
 export declare function registerGraph(value: SourceMapValue): void;
 export type ContextProviderComponent<T> = FlowComponent<{
-  value: T;
+    value: T;
 }>;
 export interface Context<T> {
-  id: symbol;
-  Provider: ContextProviderComponent<T>;
-  defaultValue: T;
+    id: symbol;
+    Provider: ContextProviderComponent<T>;
+    defaultValue: T;
 }
 /**
  * Creates a Context to handle a state scoped for the children of a component
@@ -599,10 +518,7 @@ export interface Context<T> {
  *
  * @description https://docs.solidjs.com/reference/component-apis/create-context
  */
-export declare function createContext<T>(
-  defaultValue?: undefined,
-  options?: EffectOptions
-): Context<T | undefined>;
+export declare function createContext<T>(defaultValue?: undefined, options?: EffectOptions): Context<T | undefined>;
 export declare function createContext<T>(defaultValue: T, options?: EffectOptions): Context<T>;
 /**
  * Uses a context to receive a scoped state from a parent's Context.Provider
@@ -616,7 +532,7 @@ export declare function useContext<T>(context: Context<T>): T;
 export type ResolvedJSXElement = Exclude<JSX.Element, JSX.ArrayElement>;
 export type ResolvedChildren = ResolvedJSXElement | ResolvedJSXElement[];
 export type ChildrenReturn = Accessor<ResolvedChildren> & {
-  toArray: () => ResolvedJSXElement[];
+    toArray: () => ResolvedJSXElement[];
 };
 /**
  * Resolves child elements to help interact with children
@@ -628,29 +544,22 @@ export type ChildrenReturn = Accessor<ResolvedChildren> & {
  */
 export declare function children(fn: Accessor<JSX.Element>): ChildrenReturn;
 export type SuspenseContextType = {
-  increment?: () => void;
-  decrement?: () => void;
-  inFallback?: () => boolean;
-  effects?: Computation<any>[];
-  resolved?: boolean;
+    increment?: () => void;
+    decrement?: () => void;
+    inFallback?: () => boolean;
+    effects?: Computation<any>[];
+    resolved?: boolean;
 };
 type SuspenseContext = Context<SuspenseContextType | undefined> & {
-  active?(): boolean;
-  increment?(): void;
-  decrement?(): void;
+    active?(): boolean;
+    increment?(): void;
+    decrement?(): void;
 };
 declare let SuspenseContext: SuspenseContext;
 export declare function getSuspenseContext(): SuspenseContext;
-export declare function enableExternalSource(
-  factory: ExternalSourceFactory,
-  untrack?: <V>(fn: () => V) => V
-): void;
+export declare function enableExternalSource(factory: ExternalSourceFactory, untrack?: <V>(fn: () => V) => V): void;
 export declare function readSignal(this: SignalState<any> | Memo<any>): any;
-export declare function writeSignal(
-  node: SignalState<any> | Memo<any>,
-  value: any,
-  isComp?: boolean
-): any;
+export declare function writeSignal(node: SignalState<any> | Memo<any>, value: any, isComp?: boolean): any;
 /**
  * @deprecated since version 1.7.0 and will be removed in next major - use catchError instead
  * onError - run an effect whenever an error is thrown within the context of the child scopes
diff --git a/types/render/Suspense.d.ts b/types/render/Suspense.d.ts
index 561699209de7979518e10520a637f60fc91e0087..7cbe6ed253a4fd36b8498575fc46e83916301d84 100644
--- a/types/render/Suspense.d.ts
+++ b/types/render/Suspense.d.ts
@@ -5,9 +5,9 @@ import type { JSX } from "../jsx.js";
  * @description https://docs.solidjs.com/reference/components/suspense-list
  */
 export declare function SuspenseList(props: {
-  children: JSX.Element;
-  revealOrder: "forwards" | "backwards" | "together";
-  tail?: "collapsed" | "hidden";
+    children: JSX.Element;
+    revealOrder: "forwards" | "backwards" | "together";
+    tail?: "collapsed" | "hidden";
 }): JSX.Element;
 /**
  * Tracks all resources inside a component and renders a fallback until they are all resolved
@@ -21,6 +21,6 @@ export declare function SuspenseList(props: {
  * @description https://docs.solidjs.com/reference/components/suspense
  */
 export declare function Suspense(props: {
-  fallback?: JSX.Element;
-  children: JSX.Element;
+    fallback?: JSX.Element;
+    children: JSX.Element;
 }): JSX.Element;
diff --git a/types/render/component.d.ts b/types/render/component.d.ts
index 10f7380c3f167862407fd12f8433f160b77ae789..572198c0b52d318d25a84b286849e33b9d52e4d6 100644
--- a/types/render/component.d.ts
+++ b/types/render/component.d.ts
@@ -11,7 +11,7 @@ export type Component<P extends Record<string, any> = {}> = (props: P) => JSX.El
  * would silently throw them away.
  */
 export type VoidProps<P extends Record<string, any> = {}> = P & {
-  children?: never;
+    children?: never;
 };
 /**
  * `VoidComponent` forbids the `children` prop.
@@ -25,7 +25,7 @@ export type VoidComponent<P extends Record<string, any> = {}> = Component<VoidPr
  * Use this for components that you want to accept children.
  */
 export type ParentProps<P extends Record<string, any> = {}> = P & {
-  children?: JSX.Element;
+    children?: JSX.Element;
 };
 /**
  * `ParentComponent` allows an optional `children` prop with the usual
@@ -40,7 +40,7 @@ export type ParentComponent<P extends Record<string, any> = {}> = Component<Pare
  * Note that all JSX <Elements> are of the type `JSX.Element`.
  */
 export type FlowProps<P extends Record<string, any> = {}, C = JSX.Element> = P & {
-  children: C;
+    children: C;
 };
 /**
  * `FlowComponent` requires a `children` prop with the specified type.
@@ -48,9 +48,7 @@ export type FlowProps<P extends Record<string, any> = {}, C = JSX.Element> = P &
  * typically a function that receives specific argument types.
  * Note that all JSX <Elements> are of the type `JSX.Element`.
  */
-export type FlowComponent<P extends Record<string, any> = {}, C = JSX.Element> = Component<
-  FlowProps<P, C>
->;
+export type FlowComponent<P extends Record<string, any> = {}, C = JSX.Element> = Component<FlowProps<P, C>>;
 /** @deprecated: use `ParentProps` instead */
 export type PropsWithChildren<P extends Record<string, any> = {}> = ParentProps<P>;
 export type ValidComponent = keyof JSX.IntrinsicElements | Component<any> | (string & {});
@@ -61,87 +59,53 @@ export type ValidComponent = keyof JSX.IntrinsicElements | Component<any> | (str
  * ComponentProps<typeof Portal> // { mount?: Node; useShadow?: boolean; children: JSX.Element }
  * ComponentProps<'div'> // JSX.HTMLAttributes<HTMLDivElement>
  */
-export type ComponentProps<T extends ValidComponent> = T extends Component<infer P>
-  ? P
-  : T extends keyof JSX.IntrinsicElements
-  ? JSX.IntrinsicElements[T]
-  : Record<string, unknown>;
+export type ComponentProps<T extends ValidComponent> = T extends Component<infer P> ? P : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : Record<string, unknown>;
 /**
  * Type of `props.ref`, for use in `Component` or `props` typing.
  *
  * @example Component<{ref: Ref<Element>}>
  */
 export type Ref<T> = T | ((val: T) => void);
-export declare function createComponent<T extends Record<string, any>>(
-  Comp: Component<T>,
-  props: T
-): JSX.Element;
+export declare function createComponent<T extends Record<string, any>>(Comp: Component<T>, props: T): JSX.Element;
 type DistributeOverride<T, F> = T extends undefined ? F : T;
-type Override<T, U> = T extends any
-  ? U extends any
-    ? {
-        [K in keyof T]: K extends keyof U ? DistributeOverride<U[K], T[K]> : T[K];
-      } & {
-        [K in keyof U]: K extends keyof T ? DistributeOverride<U[K], T[K]> : U[K];
-      }
-    : T & U
-  : T & U;
-type OverrideSpread<T, U> = T extends any
-  ? {
-      [K in keyof ({
+type Override<T, U> = T extends any ? U extends any ? {
+    [K in keyof T]: K extends keyof U ? DistributeOverride<U[K], T[K]> : T[K];
+} & {
+    [K in keyof U]: K extends keyof T ? DistributeOverride<U[K], T[K]> : U[K];
+} : T & U : T & U;
+type OverrideSpread<T, U> = T extends any ? {
+    [K in keyof ({
         [K in keyof T]: any;
-      } & {
+    } & {
         [K in keyof U]?: any;
-      } & {
+    } & {
         [K in U extends any ? keyof U : keyof U]?: any;
-      })]: K extends keyof T
-        ? Exclude<U extends any ? U[K & keyof U] : never, undefined> | T[K]
-        : U extends any
-        ? U[K & keyof U]
-        : never;
-    }
-  : T & U;
-type Simplify<T> = T extends any
-  ? {
-      [K in keyof T]: T[K];
-    }
-  : T;
+    })]: K extends keyof T ? Exclude<U extends any ? U[K & keyof U] : never, undefined> | T[K] : U extends any ? U[K & keyof U] : never;
+} : T & U;
+type Simplify<T> = T extends any ? {
+    [K in keyof T]: T[K];
+} : T;
 type _MergeProps<T extends unknown[], Curr = {}> = T extends [
-  infer Next | (() => infer Next),
-  ...infer Rest
-]
-  ? _MergeProps<Rest, Override<Curr, Next>>
-  : T extends [...infer Rest, infer Next | (() => infer Next)]
-  ? Override<_MergeProps<Rest, Curr>, Next>
-  : T extends []
-  ? Curr
-  : T extends (infer I | (() => infer I))[]
-  ? OverrideSpread<Curr, I>
-  : Curr;
+    infer Next | (() => infer Next),
+    ...infer Rest
+] ? _MergeProps<Rest, Override<Curr, Next>> : T extends [...infer Rest, infer Next | (() => infer Next)] ? Override<_MergeProps<Rest, Curr>, Next> : T extends [] ? Curr : T extends (infer I | (() => infer I))[] ? OverrideSpread<Curr, I> : Curr;
 export type MergeProps<T extends unknown[]> = Simplify<_MergeProps<T>>;
 export declare function mergeProps<T extends unknown[]>(...sources: T): MergeProps<T>;
 export type SplitProps<T, K extends (readonly (keyof T)[])[]> = [
-  ...{
-    [P in keyof K]: P extends `${number}`
-      ? Pick<T, Extract<K[P], readonly (keyof T)[]>[number]>
-      : never;
-  },
-  {
-    [P in keyof T as Exclude<P, K[number][number]>]: T[P];
-  }
+    ...{
+        [P in keyof K]: P extends `${number}` ? Pick<T, Extract<K[P], readonly (keyof T)[]>[number]> : never;
+    },
+    {
+        [P in keyof T as Exclude<P, K[number][number]>]: T[P];
+    }
 ];
-export declare function splitProps<
-  T extends Record<any, any>,
-  K extends [readonly (keyof T)[], ...(readonly (keyof T)[])[]]
->(props: T, ...keys: K): SplitProps<T, K>;
-export declare function lazy<T extends Component<any>>(
-  fn: () => Promise<{
-    default: T;
-  }>
-): T & {
-  preload: () => Promise<{
+export declare function splitProps<T extends Record<any, any>, K extends [readonly (keyof T)[], ...(readonly (keyof T)[])[]]>(props: T, ...keys: K): SplitProps<T, K>;
+export declare function lazy<T extends Component<any>>(fn: () => Promise<{
     default: T;
-  }>;
+}>): T & {
+    preload: () => Promise<{
+        default: T;
+    }>;
 };
 export declare function createUniqueId(): string;
 export {};
diff --git a/types/render/flow.d.ts b/types/render/flow.d.ts
index 2095166db9e889eaded22761cdc8bbdecb09d4ef..fa3e1bab34d66cc48fe081dee4f3ad4d3f433758 100644
--- a/types/render/flow.d.ts
+++ b/types/render/flow.d.ts
@@ -14,9 +14,9 @@ import type { JSX } from "../jsx.js";
  * @description https://docs.solidjs.com/reference/components/for
  */
 export declare function For<T extends readonly any[], U extends JSX.Element>(props: {
-  each: T | undefined | null | false;
-  fallback?: JSX.Element;
-  children: (item: T[number], index: Accessor<number>) => U;
+    each: T | undefined | null | false;
+    fallback?: JSX.Element;
+    children: (item: T[number], index: Accessor<number>) => U;
 }): JSX.Element;
 /**
  * Non-keyed iteration over a list creating elements from its items
@@ -32,32 +32,26 @@ export declare function For<T extends readonly any[], U extends JSX.Element>(pro
  * @description https://docs.solidjs.com/reference/components/index
  */
 export declare function Index<T extends readonly any[], U extends JSX.Element>(props: {
-  each: T | undefined | null | false;
-  fallback?: JSX.Element;
-  children: (item: Accessor<T[number]>, index: number) => U;
+    each: T | undefined | null | false;
+    fallback?: JSX.Element;
+    children: (item: Accessor<T[number]>, index: number) => U;
 }): JSX.Element;
 type RequiredParameter<T> = T extends () => unknown ? never : T;
 /**
  * Conditionally render its children or an optional fallback component
  * @description https://docs.solidjs.com/reference/components/show
  */
-export declare function Show<
-  T,
-  TRenderFunction extends (item: Accessor<NonNullable<T>>) => JSX.Element
->(props: {
-  when: T | undefined | null | false;
-  keyed?: false;
-  fallback?: JSX.Element;
-  children: JSX.Element | RequiredParameter<TRenderFunction>;
+export declare function Show<T, TRenderFunction extends (item: Accessor<NonNullable<T>>) => JSX.Element>(props: {
+    when: T | undefined | null | false;
+    keyed?: false;
+    fallback?: JSX.Element;
+    children: JSX.Element | RequiredParameter<TRenderFunction>;
 }): JSX.Element;
-export declare function Show<
-  T,
-  TRenderFunction extends (item: NonNullable<T>) => JSX.Element
->(props: {
-  when: T | undefined | null | false;
-  keyed: true;
-  fallback?: JSX.Element;
-  children: JSX.Element | RequiredParameter<TRenderFunction>;
+export declare function Show<T, TRenderFunction extends (item: NonNullable<T>) => JSX.Element>(props: {
+    when: T | undefined | null | false;
+    keyed: true;
+    fallback?: JSX.Element;
+    children: JSX.Element | RequiredParameter<TRenderFunction>;
 }): JSX.Element;
 /**
  * Switches between content based on mutually exclusive conditions
@@ -74,13 +68,13 @@ export declare function Show<
  * @description https://docs.solidjs.com/reference/components/switch-and-match
  */
 export declare function Switch(props: {
-  fallback?: JSX.Element;
-  children: JSX.Element;
+    fallback?: JSX.Element;
+    children: JSX.Element;
 }): JSX.Element;
 export type MatchProps<T> = {
-  when: T | undefined | null | false;
-  keyed?: boolean;
-  children: JSX.Element | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => JSX.Element);
+    when: T | undefined | null | false;
+    keyed?: boolean;
+    children: JSX.Element | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => JSX.Element);
 };
 /**
  * Selects a content based on condition when inside a `<Switch>` control flow
@@ -91,21 +85,15 @@ export type MatchProps<T> = {
  * ```
  * @description https://docs.solidjs.com/reference/components/switch-and-match
  */
-export declare function Match<
-  T,
-  TRenderFunction extends (item: Accessor<NonNullable<T>>) => JSX.Element
->(props: {
-  when: T | undefined | null | false;
-  keyed?: false;
-  children: JSX.Element | RequiredParameter<TRenderFunction>;
+export declare function Match<T, TRenderFunction extends (item: Accessor<NonNullable<T>>) => JSX.Element>(props: {
+    when: T | undefined | null | false;
+    keyed?: false;
+    children: JSX.Element | RequiredParameter<TRenderFunction>;
 }): JSX.Element;
-export declare function Match<
-  T,
-  TRenderFunction extends (item: NonNullable<T>) => JSX.Element
->(props: {
-  when: T | undefined | null | false;
-  keyed: true;
-  children: JSX.Element | RequiredParameter<TRenderFunction>;
+export declare function Match<T, TRenderFunction extends (item: NonNullable<T>) => JSX.Element>(props: {
+    when: T | undefined | null | false;
+    keyed: true;
+    children: JSX.Element | RequiredParameter<TRenderFunction>;
 }): JSX.Element;
 export declare function resetErrorBoundaries(): void;
 /**
@@ -124,7 +112,7 @@ export declare function resetErrorBoundaries(): void;
  * @description https://docs.solidjs.com/reference/components/error-boundary
  */
 export declare function ErrorBoundary(props: {
-  fallback: JSX.Element | ((err: any, reset: () => void) => JSX.Element);
-  children: JSX.Element;
+    fallback: JSX.Element | ((err: any, reset: () => void) => JSX.Element);
+    children: JSX.Element;
 }): JSX.Element;
 export {};
diff --git a/types/render/hydration.d.ts b/types/render/hydration.d.ts
index 53d2e4b189d1ced9266792d827a755f2c1af58e4..cc7c5b322c9016fd563f47f4fec7ce4bbbe5eac5 100644
--- a/types/render/hydration.d.ts
+++ b/types/render/hydration.d.ts
@@ -1,22 +1,22 @@
 import { Computation } from "../reactive/signal.js";
 export type HydrationContext = {
-  id: string;
-  count: number;
+    id: string;
+    count: number;
 };
 type SharedConfig = {
-  context?: HydrationContext;
-  resources?: {
-    [key: string]: any;
-  };
-  load?: (id: string) => Promise<any> | any;
-  has?: (id: string) => boolean;
-  gather?: (key: string) => void;
-  registry?: Map<string, Element>;
-  done?: boolean;
-  count?: number;
-  effects?: Computation<any, any>[];
-  getContextId(): string;
-  getNextContextId(): string;
+    context?: HydrationContext;
+    resources?: {
+        [key: string]: any;
+    };
+    load?: (id: string) => Promise<any> | any;
+    has?: (id: string) => boolean;
+    gather?: (key: string) => void;
+    registry?: Map<string, Element>;
+    done?: boolean;
+    count?: number;
+    effects?: Computation<any, any>[];
+    getContextId(): string;
+    getNextContextId(): string;
 };
 export declare const sharedConfig: SharedConfig;
 export declare function setHydrateContext(context?: HydrationContext): void;
diff --git a/types/server/index.d.ts b/types/server/index.d.ts
index 13593881387503d24dcc452298ab2112a7c47044..2e608c8b7f823e1869f7d208fa40496c22e9df2c 100644
--- a/types/server/index.d.ts
+++ b/types/server/index.d.ts
@@ -1,58 +1,3 @@
-export {
-  catchError,
-  createRoot,
-  createSignal,
-  createComputed,
-  createRenderEffect,
-  createEffect,
-  createReaction,
-  createDeferred,
-  createSelector,
-  createMemo,
-  getListener,
-  onMount,
-  onCleanup,
-  onError,
-  untrack,
-  batch,
-  on,
-  children,
-  createContext,
-  useContext,
-  getOwner,
-  runWithOwner,
-  equalFn,
-  requestCallback,
-  mapArray,
-  indexArray,
-  observable,
-  from,
-  $PROXY,
-  $DEVCOMP,
-  $TRACK,
-  DEV,
-  enableExternalSource
-} from "./reactive.js";
-export {
-  mergeProps,
-  splitProps,
-  createComponent,
-  For,
-  Index,
-  Show,
-  Switch,
-  Match,
-  ErrorBoundary,
-  Suspense,
-  SuspenseList,
-  createResource,
-  resetErrorBoundaries,
-  enableScheduling,
-  enableHydration,
-  startTransition,
-  useTransition,
-  createUniqueId,
-  lazy,
-  sharedConfig
-} from "./rendering.js";
+export { catchError, createRoot, createSignal, createComputed, createRenderEffect, createEffect, createReaction, createDeferred, createSelector, createMemo, getListener, onMount, onCleanup, onError, untrack, batch, on, children, createContext, useContext, getOwner, runWithOwner, equalFn, requestCallback, mapArray, indexArray, observable, from, $PROXY, $DEVCOMP, $TRACK, DEV, enableExternalSource } from "./reactive.js";
+export { mergeProps, splitProps, createComponent, For, Index, Show, Switch, Match, ErrorBoundary, Suspense, SuspenseList, createResource, resetErrorBoundaries, enableScheduling, enableHydration, startTransition, useTransition, createUniqueId, lazy, sharedConfig } from "./rendering.js";
 export type { Component, Resource } from "./rendering.js";
diff --git a/types/server/reactive.d.ts b/types/server/reactive.d.ts
index 50ea16a66036b71daf11c61fb09d6c7f0e27dd03..08ee495d35367a4e486b5fab83284c8d166b9543 100644
--- a/types/server/reactive.d.ts
+++ b/types/server/reactive.d.ts
@@ -4,118 +4,87 @@ export declare const $TRACK: unique symbol;
 export declare const $DEVCOMP: unique symbol;
 export declare const DEV: undefined;
 export type Accessor<T> = () => T;
-export type Setter<T> = undefined extends T
-  ? <U extends T>(value?: (U extends Function ? never : U) | ((prev?: T) => U)) => U
-  : <U extends T>(value: (U extends Function ? never : U) | ((prev: T) => U)) => U;
+export type Setter<T> = undefined extends T ? <U extends T>(value?: (U extends Function ? never : U) | ((prev?: T) => U)) => U : <U extends T>(value: (U extends Function ? never : U) | ((prev: T) => U)) => U;
 export type Signal<T> = [get: Accessor<T>, set: Setter<T>];
 export declare function castError(err: unknown): Error;
 export declare let Owner: Owner | null;
 interface Owner {
-  owner: Owner | null;
-  context: any | null;
-  owned: Owner[] | null;
-  cleanups: (() => void)[] | null;
+    owner: Owner | null;
+    context: any | null;
+    owned: Owner[] | null;
+    cleanups: (() => void)[] | null;
 }
 export declare function createOwner(): Owner;
-export declare function createRoot<T>(
-  fn: (dispose: () => void) => T,
-  detachedOwner?: typeof Owner
-): T;
-export declare function createSignal<T>(
-  value: T,
-  options?: {
+export declare function createRoot<T>(fn: (dispose: () => void) => T, detachedOwner?: typeof Owner): T;
+export declare function createSignal<T>(value: T, options?: {
     equals?: false | ((prev: T, next: T) => boolean);
     name?: string;
-  }
-): [get: () => T, set: (v: (T extends Function ? never : T) | ((prev: T) => T)) => T];
+}): [get: () => T, set: (v: (T extends Function ? never : T) | ((prev: T) => T)) => T];
 export declare function createComputed<T>(fn: (v?: T) => T, value?: T): void;
 export declare const createRenderEffect: typeof createComputed;
 export declare function createEffect<T>(fn: (v?: T) => T, value?: T): void;
 export declare function createReaction(fn: () => void): (fn: () => void) => void;
 export declare function createMemo<T>(fn: (v?: T) => T, value?: T): () => T;
 export declare function createDeferred<T>(source: () => T): () => T;
-export declare function createSelector<T>(
-  source: () => T,
-  fn?: (k: T, value: T) => boolean
-): (k: T) => boolean;
+export declare function createSelector<T>(source: () => T, fn?: (k: T, value: T) => boolean): (k: T) => boolean;
 export declare function batch<T>(fn: () => T): T;
 export declare const untrack: typeof batch;
-export declare function on<T, U>(
-  deps: Array<() => T> | (() => T),
-  fn: (value: Array<T> | T, prev?: Array<T> | T, prevResults?: U) => U,
-  options?: {
+export declare function on<T, U>(deps: Array<() => T> | (() => T), fn: (value: Array<T> | T, prev?: Array<T> | T, prevResults?: U) => U, options?: {
     defer?: boolean;
-  }
-): (prev?: U) => U | undefined;
+}): (prev?: U) => U | undefined;
 export declare function onMount(fn: () => void): void;
 export declare function onCleanup(fn: () => void): () => void;
 export declare function cleanNode(node: Owner): void;
 export declare function catchError<T>(fn: () => T, handler: (err: Error) => void): T | undefined;
 export declare function getListener(): null;
 export interface Context<T> {
-  id: symbol;
-  Provider: (props: { value: T; children: any }) => any;
-  defaultValue?: T;
+    id: symbol;
+    Provider: (props: {
+        value: T;
+        children: any;
+    }) => any;
+    defaultValue?: T;
 }
 export declare function createContext<T>(defaultValue?: T): Context<T>;
 export declare function useContext<T>(context: Context<T>): T;
 export declare function getOwner(): Owner | null;
 type ChildrenReturn = Accessor<any> & {
-  toArray: () => any[];
+    toArray: () => any[];
 };
 export declare function children(fn: () => any): ChildrenReturn;
 export declare function runWithOwner<T>(o: typeof Owner, fn: () => T): T | undefined;
 export interface Task {
-  id: number;
-  fn: ((didTimeout: boolean) => void) | null;
-  startTime: number;
-  expirationTime: number;
+    id: number;
+    fn: ((didTimeout: boolean) => void) | null;
+    startTime: number;
+    expirationTime: number;
 }
-export declare function requestCallback(
-  fn: () => void,
-  options?: {
+export declare function requestCallback(fn: () => void, options?: {
     timeout: number;
-  }
-): Task;
+}): Task;
 export declare function cancelCallback(task: Task): void;
-export declare function mapArray<T, U>(
-  list: Accessor<readonly T[] | undefined | null | false>,
-  mapFn: (v: T, i: Accessor<number>) => U,
-  options?: {
+export declare function mapArray<T, U>(list: Accessor<readonly T[] | undefined | null | false>, mapFn: (v: T, i: Accessor<number>) => U, options?: {
     fallback?: Accessor<any>;
-  }
-): () => U[];
-export declare function indexArray<T, U>(
-  list: Accessor<readonly T[] | undefined | null | false>,
-  mapFn: (v: Accessor<T>, i: number) => U,
-  options?: {
+}): () => U[];
+export declare function indexArray<T, U>(list: Accessor<readonly T[] | undefined | null | false>, mapFn: (v: Accessor<T>, i: number) => U, options?: {
     fallback?: Accessor<any>;
-  }
-): () => U[];
-export type ObservableObserver<T> =
-  | ((v: T) => void)
-  | {
-      next: (v: T) => void;
-      error?: (v: any) => void;
-      complete?: (v: boolean) => void;
-    };
+}): () => U[];
+export type ObservableObserver<T> = ((v: T) => void) | {
+    next: (v: T) => void;
+    error?: (v: any) => void;
+    complete?: (v: boolean) => void;
+};
 export declare function observable<T>(input: Accessor<T>): {
-  subscribe(observer: ObservableObserver<T>): {
-    unsubscribe(): void;
-  };
-  [Symbol.observable](): any;
+    subscribe(observer: ObservableObserver<T>): {
+        unsubscribe(): void;
+    };
+    [Symbol.observable](): any;
 };
-export declare function from<T>(
-  producer:
-    | ((setter: Setter<T>) => () => void)
-    | {
-        subscribe: (fn: (v: T) => void) =>
-          | (() => void)
-          | {
-              unsubscribe: () => void;
-            };
-      }
-): Accessor<T>;
+export declare function from<T>(producer: ((setter: Setter<T>) => () => void) | {
+    subscribe: (fn: (v: T) => void) => (() => void) | {
+        unsubscribe: () => void;
+    };
+}): Accessor<T>;
 export declare function enableExternalSource(factory: any): void;
 /**
  * @deprecated since version 1.7.0 and will be removed in next major - use catchError instead
diff --git a/types/server/rendering.d.ts b/types/server/rendering.d.ts
index 6dfd7e15aab738db796cd5e41a8b5763b17649f7..9cee7b421f78feb15210be84b1d3713a5b358dfe 100644
--- a/types/server/rendering.d.ts
+++ b/types/server/rendering.d.ts
@@ -2,229 +2,158 @@ import { Accessor, Setter, Signal } from "./reactive.js";
 import type { JSX } from "../jsx.js";
 export type Component<P = {}> = (props: P) => JSX.Element;
 export type VoidProps<P = {}> = P & {
-  children?: never;
+    children?: never;
 };
 export type VoidComponent<P = {}> = Component<VoidProps<P>>;
 export type ParentProps<P = {}> = P & {
-  children?: JSX.Element;
+    children?: JSX.Element;
 };
 export type ParentComponent<P = {}> = Component<ParentProps<P>>;
 export type FlowProps<P = {}, C = JSX.Element> = P & {
-  children: C;
+    children: C;
 };
 export type FlowComponent<P = {}, C = JSX.Element> = Component<FlowProps<P, C>>;
 export type Ref<T> = T | ((val: T) => void);
 export type ValidComponent = keyof JSX.IntrinsicElements | Component<any> | (string & {});
-export type ComponentProps<T extends ValidComponent> = T extends Component<infer P>
-  ? P
-  : T extends keyof JSX.IntrinsicElements
-  ? JSX.IntrinsicElements[T]
-  : Record<string, unknown>;
+export type ComponentProps<T extends ValidComponent> = T extends Component<infer P> ? P : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : Record<string, unknown>;
 type SharedConfig = {
-  context?: HydrationContext;
-  getContextId(): string;
-  getNextContextId(): string;
+    context?: HydrationContext;
+    getContextId(): string;
+    getNextContextId(): string;
 };
 export declare const sharedConfig: SharedConfig;
 export declare function createUniqueId(): string;
 export declare function createComponent<T>(Comp: (props: T) => JSX.Element, props: T): JSX.Element;
 export declare function mergeProps<T, U>(source: T, source1: U): T & U;
 export declare function mergeProps<T, U, V>(source: T, source1: U, source2: V): T & U & V;
-export declare function mergeProps<T, U, V, W>(
-  source: T,
-  source1: U,
-  source2: V,
-  source3: W
-): T & U & V & W;
-export declare function splitProps<T extends object, K1 extends keyof T>(
-  props: T,
-  ...keys: [K1[]]
-): [Pick<T, K1>, Omit<T, K1>];
-export declare function splitProps<T extends object, K1 extends keyof T, K2 extends keyof T>(
-  props: T,
-  ...keys: [K1[], K2[]]
-): [Pick<T, K1>, Pick<T, K2>, Omit<T, K1 | K2>];
-export declare function splitProps<
-  T extends object,
-  K1 extends keyof T,
-  K2 extends keyof T,
-  K3 extends keyof T
->(
-  props: T,
-  ...keys: [K1[], K2[], K3[]]
-): [Pick<T, K1>, Pick<T, K2>, Pick<T, K3>, Omit<T, K1 | K2 | K3>];
-export declare function splitProps<
-  T extends object,
-  K1 extends keyof T,
-  K2 extends keyof T,
-  K3 extends keyof T,
-  K4 extends keyof T
->(
-  props: T,
-  ...keys: [K1[], K2[], K3[], K4[]]
-): [Pick<T, K1>, Pick<T, K2>, Pick<T, K3>, Pick<T, K4>, Omit<T, K1 | K2 | K3 | K4>];
-export declare function splitProps<
-  T extends object,
-  K1 extends keyof T,
-  K2 extends keyof T,
-  K3 extends keyof T,
-  K4 extends keyof T,
-  K5 extends keyof T
->(
-  props: T,
-  ...keys: [K1[], K2[], K3[], K4[], K5[]]
-): [
-  Pick<T, K1>,
-  Pick<T, K2>,
-  Pick<T, K3>,
-  Pick<T, K4>,
-  Pick<T, K5>,
-  Omit<T, K1 | K2 | K3 | K4 | K5>
+export declare function mergeProps<T, U, V, W>(source: T, source1: U, source2: V, source3: W): T & U & V & W;
+export declare function splitProps<T extends object, K1 extends keyof T>(props: T, ...keys: [K1[]]): [Pick<T, K1>, Omit<T, K1>];
+export declare function splitProps<T extends object, K1 extends keyof T, K2 extends keyof T>(props: T, ...keys: [K1[], K2[]]): [Pick<T, K1>, Pick<T, K2>, Omit<T, K1 | K2>];
+export declare function splitProps<T extends object, K1 extends keyof T, K2 extends keyof T, K3 extends keyof T>(props: T, ...keys: [K1[], K2[], K3[]]): [Pick<T, K1>, Pick<T, K2>, Pick<T, K3>, Omit<T, K1 | K2 | K3>];
+export declare function splitProps<T extends object, K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, K4 extends keyof T>(props: T, ...keys: [K1[], K2[], K3[], K4[]]): [Pick<T, K1>, Pick<T, K2>, Pick<T, K3>, Pick<T, K4>, Omit<T, K1 | K2 | K3 | K4>];
+export declare function splitProps<T extends object, K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, K4 extends keyof T, K5 extends keyof T>(props: T, ...keys: [K1[], K2[], K3[], K4[], K5[]]): [
+    Pick<T, K1>,
+    Pick<T, K2>,
+    Pick<T, K3>,
+    Pick<T, K4>,
+    Pick<T, K5>,
+    Omit<T, K1 | K2 | K3 | K4 | K5>
 ];
 export declare function For<T>(props: {
-  each: T[];
-  fallback?: string;
-  children: (item: T, index: () => number) => string;
+    each: T[];
+    fallback?: string;
+    children: (item: T, index: () => number) => string;
 }): string | any[] | undefined;
 export declare function Index<T>(props: {
-  each: T[];
-  fallback?: string;
-  children: (item: () => T, index: number) => string;
+    each: T[];
+    fallback?: string;
+    children: (item: () => T, index: number) => string;
 }): string | any[] | undefined;
 /**
  * Conditionally render its children or an optional fallback component
  * @description https://docs.solidjs.com/reference/components/show
  */
 export declare function Show<T>(props: {
-  when: T | undefined | null | false;
-  keyed?: boolean;
-  fallback?: string;
-  children: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);
+    when: T | undefined | null | false;
+    keyed?: boolean;
+    fallback?: string;
+    children: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);
 }): string;
 export declare function Switch(props: {
-  fallback?: string;
-  children: MatchProps<unknown> | MatchProps<unknown>[];
+    fallback?: string;
+    children: MatchProps<unknown> | MatchProps<unknown>[];
 }): string;
 type MatchProps<T> = {
-  when: T | false;
-  keyed?: boolean;
-  children: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);
+    when: T | false;
+    keyed?: boolean;
+    children: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);
 };
 export declare function Match<T>(props: MatchProps<T>): MatchProps<T>;
 export declare function resetErrorBoundaries(): void;
 export declare function ErrorBoundary(props: {
-  fallback: string | ((err: any, reset: () => void) => string);
-  children: string;
-}):
-  | string
-  | ((err: any, reset: () => void) => string)
-  | {
-      t: string;
-    };
+    fallback: string | ((err: any, reset: () => void) => string);
+    children: string;
+}): string | ((err: any, reset: () => void) => string) | {
+    t: string;
+};
 export interface Resource<T> {
-  (): T | undefined;
-  state: "unresolved" | "pending" | "ready" | "refreshing" | "errored";
-  loading: boolean;
-  error: any;
-  latest: T | undefined;
+    (): T | undefined;
+    state: "unresolved" | "pending" | "ready" | "refreshing" | "errored";
+    loading: boolean;
+    error: any;
+    latest: T | undefined;
 }
 type SuspenseContextType = {
-  resources: Map<
-    string,
-    {
-      loading: boolean;
-      error: any;
-    }
-  >;
-  completed: () => void;
+    resources: Map<string, {
+        loading: boolean;
+        error: any;
+    }>;
+    completed: () => void;
 };
 export type ResourceActions<T> = {
-  mutate: Setter<T>;
-  refetch: (info?: unknown) => void;
+    mutate: Setter<T>;
+    refetch: (info?: unknown) => void;
 };
 export type ResourceReturn<T> = [Resource<T>, ResourceActions<T>];
 export type ResourceSource<S> = S | false | null | undefined | (() => S | false | null | undefined);
 export type ResourceFetcher<S, T> = (k: S, info: ResourceFetcherInfo<T>) => T | Promise<T>;
 export type ResourceFetcherInfo<T> = {
-  value: T | undefined;
-  refetching?: unknown;
+    value: T | undefined;
+    refetching?: unknown;
 };
-export type ResourceOptions<T> = undefined extends T
-  ? {
-      initialValue?: T;
-      name?: string;
-      deferStream?: boolean;
-      ssrLoadFrom?: "initial" | "server";
-      storage?: () => Signal<T | undefined>;
-      onHydrated?: <S, T>(k: S, info: ResourceFetcherInfo<T>) => void;
-    }
-  : {
-      initialValue: T;
-      name?: string;
-      deferStream?: boolean;
-      ssrLoadFrom?: "initial" | "server";
-      storage?: (v?: T) => Signal<T | undefined>;
-      onHydrated?: <S, T>(k: S, info: ResourceFetcherInfo<T>) => void;
-    };
-export declare function createResource<T, S = true>(
-  fetcher: ResourceFetcher<S, T>,
-  options?: ResourceOptions<undefined>
-): ResourceReturn<T | undefined>;
-export declare function createResource<T, S = true>(
-  fetcher: ResourceFetcher<S, T>,
-  options: ResourceOptions<T>
-): ResourceReturn<T>;
-export declare function createResource<T, S>(
-  source: ResourceSource<S>,
-  fetcher: ResourceFetcher<S, T>,
-  options?: ResourceOptions<undefined>
-): ResourceReturn<T | undefined>;
-export declare function createResource<T, S>(
-  source: ResourceSource<S>,
-  fetcher: ResourceFetcher<S, T>,
-  options: ResourceOptions<T>
-): ResourceReturn<T>;
-export declare function lazy<T extends Component<any>>(
-  fn: () => Promise<{
-    default: T;
-  }>
-): T & {
-  preload: () => Promise<{
+export type ResourceOptions<T> = undefined extends T ? {
+    initialValue?: T;
+    name?: string;
+    deferStream?: boolean;
+    ssrLoadFrom?: "initial" | "server";
+    storage?: () => Signal<T | undefined>;
+    onHydrated?: <S, T>(k: S, info: ResourceFetcherInfo<T>) => void;
+} : {
+    initialValue: T;
+    name?: string;
+    deferStream?: boolean;
+    ssrLoadFrom?: "initial" | "server";
+    storage?: (v?: T) => Signal<T | undefined>;
+    onHydrated?: <S, T>(k: S, info: ResourceFetcherInfo<T>) => void;
+};
+export declare function createResource<T, S = true>(fetcher: ResourceFetcher<S, T>, options?: ResourceOptions<undefined>): ResourceReturn<T | undefined>;
+export declare function createResource<T, S = true>(fetcher: ResourceFetcher<S, T>, options: ResourceOptions<T>): ResourceReturn<T>;
+export declare function createResource<T, S>(source: ResourceSource<S>, fetcher: ResourceFetcher<S, T>, options?: ResourceOptions<undefined>): ResourceReturn<T | undefined>;
+export declare function createResource<T, S>(source: ResourceSource<S>, fetcher: ResourceFetcher<S, T>, options: ResourceOptions<T>): ResourceReturn<T>;
+export declare function lazy<T extends Component<any>>(fn: () => Promise<{
     default: T;
-  }>;
+}>): T & {
+    preload: () => Promise<{
+        default: T;
+    }>;
 };
 export declare function enableScheduling(): void;
 export declare function enableHydration(): void;
 export declare function startTransition(fn: () => any): void;
 export declare function useTransition(): [() => boolean, (fn: () => any) => void];
 type HydrationContext = {
-  id: string;
-  count: number;
-  serialize: (id: string, v: Promise<any> | any, deferStream?: boolean) => void;
-  nextRoot: (v: any) => string;
-  replace: (id: string, replacement: () => any) => void;
-  block: (p: Promise<any>) => void;
-  resources: Record<string, any>;
-  suspense: Record<string, SuspenseContextType>;
-  registerFragment: (v: string) => (v?: string, err?: any) => boolean;
-  lazy: Record<string, Promise<any>>;
-  async?: boolean;
-  noHydrate: boolean;
+    id: string;
+    count: number;
+    serialize: (id: string, v: Promise<any> | any, deferStream?: boolean) => void;
+    nextRoot: (v: any) => string;
+    replace: (id: string, replacement: () => any) => void;
+    block: (p: Promise<any>) => void;
+    resources: Record<string, any>;
+    suspense: Record<string, SuspenseContextType>;
+    registerFragment: (v: string) => (v?: string, err?: any) => boolean;
+    lazy: Record<string, Promise<any>>;
+    async?: boolean;
+    noHydrate: boolean;
 };
 export declare function SuspenseList(props: {
-  children: string;
-  revealOrder: "forwards" | "backwards" | "together";
-  tail?: "collapsed" | "hidden";
+    children: string;
+    revealOrder: "forwards" | "backwards" | "together";
+    tail?: "collapsed" | "hidden";
 }): string;
-export declare function Suspense(props: { fallback?: string; children: string }):
-  | string
-  | number
-  | boolean
-  | Node
-  | JSX.ArrayElement
-  | {
-      t: string;
-    }
-  | null
-  | undefined;
+export declare function Suspense(props: {
+    fallback?: string;
+    children: string;
+}): string | number | boolean | Node | JSX.ArrayElement | {
+    t: string;
+} | null | undefined;
 export {};
